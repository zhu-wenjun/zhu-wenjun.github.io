<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Wenjun.Zhu">
  
  
  
  <link rel="prev" href="https://zhu-wenjun.github.io/2018/docker/" />
  <link rel="next" href="https://zhu-wenjun.github.io/2019/smartnode/" />
  <link rel="canonical" href="https://zhu-wenjun.github.io/2018/go/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Golang 信手拈来 | Uncertainty days
       
  </title>
  <meta name="title" content="Golang 信手拈来 | Uncertainty days">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://zhu-wenjun.github.io"
    },
    "articleSection" : "posts",
    "name" : "Golang 信手拈来",
    "headline" : "Golang 信手拈来",
    "description" : "Golang 信手拈来这个坑是在2018年挖的，但所有的内容都是在2019年填的👻👻👻
Golang基本特性  Golang是静态语言，需要先编译再执行，静态语言的好处是具有类型安全特性 并发(goroutine)是go语言最重要的特性之一, goroutine类似于线程，但是比线程使用的内存更少 通道（channel）是一种内置的数据结构，用于在不同的goroutine之间同步发送具有类型的消息. TODO: 测试通道传输的副本和指针功能Page5. Golang提供类无继承的类型系统，这个类型系统支持面向对象开发。 Golang的组合（composition）设计模式，只需简单地将一个类型嵌入到另一个类型，比如把类型1嵌入到类型2中，那么类型2就可以复用类型1的所有功能。 一个类型由其他更微小的类型组合而成，避免了传统的基于继承的模型。 Golang的接口(interface)实现机制，允许用户对行为进行建模，而不是对类型进行建模.不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否符合正在使用的接口. Golang可以在 https://play.golang.org 浏览器中进行调试, 并可以把你的代码Share给其他人. 所有处于同一个文件夹的代码文件，必须使用同一个包名，通常包和文件夹同名 在Golang中，如果main函数返回，整个程序也就终止了。Go程序终止时，还会关闭所有之前启动且还在运行的goroutine。写并发程序时，最佳的做法是，在main函数返回前，清理并终止所有之前启动的goroutine，或者(问题一), 如何在main（）函数结束之前检查此进程所派生了哪些goroutine，然后再尝试终止它们  1. 类型系统 1.1 基础数据类型 基础数据类型分为：整型，浮点数，复数，布尔型，字符串和常量
12个整型数据类型如下所示，int和uint的位数依赖于CPU的位数(32位或64位) //adm
   int8 int16 int32(rune) int64 uint8(byte) uint16 uint32 uint64 int uint    uint8 the set of all unsigned 8-bit integers (0 to 255) uint16 the set of all unsigned 16-bit integers (0 to 65535) uint32 the set of all unsigned 32-bit integers (0 to 4294967295) uint64 the set of all unsigned 64-bit integers (0 to 18446744073709551615) int8 the set of all signed 8-bit integers (-128 to 127) int16 the set of all signed 16-bit integers (-32768 to 32767) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) int64 the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807) float32 the set of all IEEE-754 32-bit floating-point numbers float64 the set of all IEEE-754 64-bit floating-point numbers complex64 the set of all complex numbers with float32 real and imaginary parts complex128 the set of all complex numbers with float64 real and imaginary parts byte alias for uint8 rune alias for int32 TODO: add a routine to calc the max and min value in each type.",
    "inLanguage" : "en-us",
    "author" : "Wenjun.Zhu",
    "creator" : "Wenjun.Zhu",
    "publisher": "Wenjun.Zhu",
    "accountablePerson" : "Wenjun.Zhu",
    "copyrightHolder" : "Wenjun.Zhu",
    "copyrightYear" : "2018",
    "datePublished": "2018-11-28 22:57:01 &#43;0800 &#43;0800",
    "dateModified" : "2018-11-28 22:57:01 &#43;0800 &#43;0800",
    "url" : "https://zhu-wenjun.github.io/2018/go/",
    "wordCount" : "13846",
    "keywords" : [  "Uncertainty days"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://zhu-wenjun.github.io">Uncertainty days</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://zhu-wenjun.github.io">Uncertainty days</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Golang 信手拈来</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://zhu-wenjun.github.io" rel="author">Wenjun.Zhu</a> with ♥ 
                <span class="post-time">
                on <time datetime=2018-11-28 itemprop="datePublished">November 28, 2018</time>
                </span>
                in
                

                |
                <a href="#gitalk-container" itemprop="discussionUrl">
                    <span class="post-comments-count gitalk-comment-count" itemprop="commentCount"></span>
                </a>
                
        </div>
    </header>

        
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#11-">1.1 基础数据类型</a></li>
    <li><a href="#12-type">1.2 type</a></li>
    <li><a href="#13-pointer">1.3 pointer</a></li>
    <li><a href="#14-rune">1.4 rune</a></li>
    <li><a href="#15-bool">1.5 bool</a></li>
    <li><a href="#16-byte">1.6 byte</a></li>
    <li><a href="#17-uintptr">1.7 uintptr</a></li>
    <li><a href="#18-string">1.8 string</a></li>
    <li><a href="#19-float">1.9 float</a></li>
    <li><a href="#110-complex">1.10 complex</a></li>
  </ul>

  <ul>
    <li><a href="#21-">2.1 数组声明与初始化</a></li>
    <li><a href="#22-">2.2 数组元素为指针</a></li>
    <li><a href="#23-">2.3 数组互相赋值</a></li>
    <li><a href="#24-">2.4 二维数组</a></li>
  </ul>

  <ul>
    <li><a href="#31-">3.1 切片声明和初始化</a></li>
    <li><a href="#32-make">3.2 用make创建切片</a></li>
    <li><a href="#33-append">3.3 用append附加切片</a></li>
    <li><a href="#34-copy">3.4 用copy拷贝切片</a></li>
    <li><a href="#35-">3.5 遍历切片</a></li>
    <li><a href="#36-">3.6 划分切片</a></li>
    <li><a href="#37-">3.7 二维切片</a></li>
  </ul>

  <ul>
    <li><a href="#41-">4.1 映射声明与初始化</a></li>
    <li><a href="#42-">4.2 遍历映射</a></li>
    <li><a href="#43-">4.3 有序打印</a></li>
    <li><a href="#44-">4.4 删除键值</a></li>
  </ul>

  <ul>
    <li><a href="#51-">5.1 函数签名</a></li>
    <li><a href="#52-">5.2 递归调用</a></li>
    <li><a href="#53-">5.3 函数类型</a></li>
    <li><a href="#54-">5.4 匿名函数</a></li>
    <li><a href="#55-">5.5 变参函数</a></li>
    <li><a href="#56-">5.6 延迟调用</a></li>
    <li><a href="#57-">5.7 错误处理</a></li>
    <li><a href="#58-">5.8 崩溃</a></li>
    <li><a href="#59-">5.9 恢复</a></li>
  </ul>

  <ul>
    <li><a href="#61-">6.1 方法声明</a></li>
    <li><a href="#62-">6.2 方法接收者为指针</a></li>
    <li><a href="#63-">6.3 结构体引用成员类型的方法</a></li>
    <li><a href="#64-">6.4 方法指针</a></li>
  </ul>

  <ul>
    <li><a href="#71-">7.1 接口类型</a></li>
    <li><a href="#72-">7.2 空接口类型</a></li>
    <li><a href="#73-">7.3 给接口变量赋值</a></li>
    <li><a href="#74-">7.4 类型断言</a></li>
    <li><a href="#75-type-switch">7.5 type-switch</a></li>
    <li><a href="#76-">7.6 接口嵌入</a></li>
    <li><a href="#77-">7.7 接口变量比较</a></li>
  </ul>

  <ul>
    <li><a href="#81-">8.1 什么是通道</a></li>
    <li><a href="#82-">8.2 创建通道</a></li>
    <li><a href="#83-">8.3 发送/接收数据</a></li>
    <li><a href="#84-">8.4 关闭通道</a></li>
    <li><a href="#84-timesleep">8.4 用通道替换time.Sleep</a></li>
    <li><a href="#85-">8.5 多个发送端</a></li>
    <li><a href="#85-outofmemorybug">8.5 一种能产生outofmemory的bug</a></li>
    <li><a href="#86-channel">8.6 选取合适的channel缓存大小</a></li>
    <li><a href="#83--1">8.3 通道相关的操作</a></li>
    <li><a href="#84--1">8.4 通道会崩溃的几种情况</a></li>
  </ul>

  <ul>
    <li><a href="#heading"></a></li>
    <li><a href="#91-concurrency">9.1. 并发（concurrency）</a></li>
    <li><a href="#92-waitgroup">9.2 并发同步之WaitGroup</a></li>
    <li><a href="#92-channel">9.2 并发同步之channel</a></li>
  </ul>

  <ul>
    <li><a href="#101-if">10.1 if条件执行</a></li>
    <li><a href="#102-for">10.2 for循环执行</a></li>
    <li><a href="#103-switch">10.3 switch多路执行</a></li>
    <li><a href="#104-select">10.4 select通道操作</a></li>
  </ul>

  <ul>
    <li><a href="#heading-1">可以比较的类型</a></li>
    <li><a href="#heading-2">不可比较的类型</a></li>
    <li><a href="#untyped">无类型untyped</a></li>
    <li><a href="#nil">零值为nil的类型</a></li>
    <li><a href="#printf">Printf打印参数</a></li>
    <li><a href="#heading-3">可寻址和不可寻址</a></li>
    <li><a href="#heading-4">参考资料</a></li>
  </ul>
</nav>
  </div>
</div>


    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <p><strong>Golang 信手拈来这个坑是在2018年挖的，但所有的内容都是在2019年填的👻👻👻</strong></p>
<h1 id="golang">Golang基本特性</h1>
<ol>
<li>Golang是静态语言，需要先编译再执行，静态语言的好处是具有类型安全特性</li>
<li>并发(goroutine)是go语言最重要的特性之一, goroutine类似于线程，但是比线程使用的内存更少</li>
<li>通道（channel）是一种内置的数据结构，用于在不同的goroutine之间同步发送具有类型的消息. TODO: 测试通道传输的副本和指针功能Page5.</li>
<li>Golang提供类无继承的类型系统，这个类型系统支持面向对象开发。</li>
<li>Golang的组合（composition）设计模式，只需简单地将一个类型嵌入到另一个类型，比如把类型1嵌入到类型2中，那么类型2就可以复用类型1的所有功能。
一个类型由其他更微小的类型组合而成，避免了传统的基于继承的模型。</li>
<li>Golang的接口(interface)实现机制，允许用户对行为进行建模，而不是对类型进行建模.不需要声明某个类型实现了某个接口，编译器会判断一个类型的实例是否符合正在使用的接口.</li>
<li>Golang可以在 <a href="https://play.golang.org">https://play.golang.org</a> 浏览器中进行调试, 并可以把你的代码Share给其他人.</li>
<li>所有处于同一个文件夹的代码文件，必须使用同一个包名，通常包和文件夹同名</li>
<li>在Golang中，如果main函数返回，整个程序也就终止了。Go程序终止时，还会关闭所有之前启动且还在运行的goroutine。写并发程序时，最佳的做法是，在main函数返回前，清理并终止所有之前启动的goroutine，或者(问题一), 如何在main（）函数结束之前检查此进程所派生了哪些goroutine，然后再尝试终止它们</li>
</ol>
<h1 id="1-">1. 类型系统</h1>
<h2 id="11-">1.1 基础数据类型</h2>
<p>基础数据类型分为：整型，浮点数，复数，布尔型，字符串和常量</p>
<p>12个整型数据类型如下所示，int和uint的位数依赖于CPU的位数(32位或64位) //adm</p>
<table>
<thead>
<tr>
<th align="center">int8</th>
<th align="center">int16</th>
<th align="center">int32<!-- raw HTML omitted -->(rune)</th>
<th align="center">int64</th>
<th align="center">uint8<!-- raw HTML omitted -->(byte)</th>
<th align="center">uint16</th>
<th align="center">uint32</th>
<th align="center">uint64</th>
<th align="center">int</th>
<th align="center">uint</th>
</tr>
</thead>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">uint8</span>       <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">unsigned</span>  <span style="color:#ae81ff">8</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#ae81ff">0</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">255</span>)
<span style="color:#66d9ef">uint16</span>      <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">unsigned</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#ae81ff">0</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">65535</span>)
<span style="color:#66d9ef">uint32</span>      <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">unsigned</span> <span style="color:#ae81ff">32</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#ae81ff">0</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">4294967295</span>)
<span style="color:#66d9ef">uint64</span>      <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">unsigned</span> <span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#ae81ff">0</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">18446744073709551615</span>)

<span style="color:#66d9ef">int8</span>        <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">signed</span>  <span style="color:#ae81ff">8</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">128</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">127</span>)
<span style="color:#66d9ef">int16</span>       <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">signed</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">32768</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">32767</span>)
<span style="color:#66d9ef">int32</span>       <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">signed</span> <span style="color:#ae81ff">32</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">2147483648</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">2147483647</span>)
<span style="color:#66d9ef">int64</span>       <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">signed</span> <span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">integers</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">9223372036854775808</span> <span style="color:#a6e22e">to</span> <span style="color:#ae81ff">9223372036854775807</span>)

<span style="color:#66d9ef">float32</span>     <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">IEEE</span><span style="color:#f92672">-</span><span style="color:#ae81ff">754</span> <span style="color:#ae81ff">32</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">floating</span><span style="color:#f92672">-</span><span style="color:#a6e22e">point</span> <span style="color:#a6e22e">numbers</span>
<span style="color:#66d9ef">float64</span>     <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">IEEE</span><span style="color:#f92672">-</span><span style="color:#ae81ff">754</span> <span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#a6e22e">bit</span> <span style="color:#a6e22e">floating</span><span style="color:#f92672">-</span><span style="color:#a6e22e">point</span> <span style="color:#a6e22e">numbers</span>

<span style="color:#66d9ef">complex64</span>   <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">complex</span> <span style="color:#a6e22e">numbers</span> <span style="color:#a6e22e">with</span> <span style="color:#66d9ef">float32</span> <span style="color:#a6e22e">real</span> <span style="color:#a6e22e">and</span> <span style="color:#a6e22e">imaginary</span> <span style="color:#a6e22e">parts</span>
<span style="color:#66d9ef">complex128</span>  <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">all</span> <span style="color:#a6e22e">complex</span> <span style="color:#a6e22e">numbers</span> <span style="color:#a6e22e">with</span> <span style="color:#66d9ef">float64</span> <span style="color:#a6e22e">real</span> <span style="color:#a6e22e">and</span> <span style="color:#a6e22e">imaginary</span> <span style="color:#a6e22e">parts</span>

<span style="color:#66d9ef">byte</span>        <span style="color:#a6e22e">alias</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">uint8</span>
<span style="color:#66d9ef">rune</span>        <span style="color:#a6e22e">alias</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">int32</span>
</code></pre></div><p><!-- raw HTML omitted -->TODO: add a routine to calc the max and min value in each type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">uint</span>     <span style="color:#a6e22e">either</span> <span style="color:#ae81ff">32</span> <span style="color:#a6e22e">or</span> <span style="color:#ae81ff">64</span> <span style="color:#a6e22e">bits</span>
<span style="color:#66d9ef">int</span>      <span style="color:#a6e22e">same</span> <span style="color:#a6e22e">size</span> <span style="color:#a6e22e">as</span> <span style="color:#66d9ef">uint</span>
<span style="color:#66d9ef">uintptr</span>  <span style="color:#a6e22e">an</span> <span style="color:#a6e22e">unsigned</span> <span style="color:#a6e22e">integer</span> <span style="color:#a6e22e">large</span> <span style="color:#a6e22e">enough</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">store</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">uninterpreted</span> <span style="color:#a6e22e">bits</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">pointer</span> <span style="color:#a6e22e">value</span>
</code></pre></div><p>整型的字面量有3种表现形式：10进制，8进制和16进制，以下3个整型字面量均表示十进制的15</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">15</span>  <span style="color:#75715e">// 10进制形式(一定不能以&#34;0&#34;开头)
</span><span style="color:#75715e"></span><span style="color:#ae81ff">017</span> <span style="color:#75715e">//  8进制形式(必须以&#34;0&#34;开头)
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0xF</span> <span style="color:#75715e">// 16进制形式(必须以&#34;0x&#34; 或 &#34;0X&#34;开头)
</span></code></pre></div><h2 id="12-type">1.2 type</h2>
<p>type: 类型声明(type declaration)包含2种形式：别名声明(alias declaration)和类型定义(type definition) //adm</p>
<p><strong>别名声明</strong>是为原类型T绑定一个别名，别名类型与原类型是相同的，形式为：</p>
<p><code>type indentifier = T</code></p>
<p><strong>类型定义</strong>是在原类型T的基础上创建一个新的不同类型</p>
<p><code>type indentifier  T</code></p>
<p>如下例子所示:<!-- raw HTML omitted -->
IntAlias类型是int类型的<strong>别名声明</strong>，IntAlias和int是两个相同的类型，他们的变量ia和i可以进行比较。<!-- raw HTML omitted -->
IntDefinition类型是int类型的<strong>类型定义</strong>，IntDefinition和int是两个不同的类型，他们的变量id和i是不能进行比较的。<!-- raw HTML omitted -->
如果想要id和i进行比较，可以将其中一个变量进行类型转换。IntDefinition到int的类型演变流程为IntDefinition&ndash;int，所以IntDefinition类型的id直接就可转换为(int)<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntAlias</span> = <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IntDefinition</span> <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">100</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ia</span> <span style="color:#a6e22e">IntAlias</span> = <span style="color:#ae81ff">100</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">id</span> <span style="color:#a6e22e">IntDefinition</span> = <span style="color:#ae81ff">100</span>

println(<span style="color:#e6db74">&#34;i == ia?&#34;</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ia</span>) <span style="color:#75715e">//true, i 和 ia是相同类型，相当于2个相同类型的变量在进行值的比较。
</span><span style="color:#75715e"></span><span style="color:#75715e">//println(&#34;i == id?&#34;, i == id) //invalid operation: i == id (mismatched types int and IntDefinition), 编译出错，i和id是不同的类型。
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34;i == id?&#34;</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> (<span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">id</span>)) <span style="color:#75715e">//i的类型为int。id的类型演变方式为IntDefinition--int，id从IntDefinition类型到int类型直接转换即可(int)(id)
</span></code></pre></div><p><code>i == ia? true</code><!-- raw HTML omitted -->
<code>i == id? true</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/psyd9W99doe"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a></p>
<p>byte和rune就是uint8和int32的<strong>别名声明</strong><!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
</span><span style="color:#75715e"></span><span style="color:#75715e">// used, by convention, to distinguish byte values from 8-bit unsigned
</span><span style="color:#75715e"></span><span style="color:#75715e">// integer values.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">byte</span> = <span style="color:#66d9ef">uint8</span>
<span style="color:#75715e">// rune is an alias for int32 and is equivalent to int32 in all ways. It is
</span><span style="color:#75715e"></span><span style="color:#75715e">// used, by convention, to distinguish character values from integer values.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">rune</span> = <span style="color:#66d9ef">int32</span>
</code></pre></div><p>如下例子中，T2是t1的别名声明，t1本来是不可导出的，但t1的类型别名T2首字母是大写，所以T2是可以导出的。通常可以直接将t1改为大写的T1，直接导出。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">t1</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">S</span> <span style="color:#66d9ef">string</span>
}
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T2</span> = <span style="color:#a6e22e">t1</span>

</code></pre></div><blockquote>
<p>More reference: <a href="https://colobu.com/2017/06/26/learn-go-type-aliases/">https://colobu.com/2017/06/26/learn-go-type-aliases/</a></p>
</blockquote>
<p>定义的类型(Defined Types)和非定义的类型(Non-Defined Types)，也叫命名的类型(named types)和非命名的类型(unamed types) //adm</p>
<p>**定义的类型(Defined Types)**<!-- raw HTML omitted -->
     <code>1.所有的基础类型都是“定义的类型(Defined Types)”，比如int, string, bool, float等类型</code><!-- raw HTML omitted -->
     <code>2.通过“类型定义”创建出来的类型属于“定义的类型(Defined Types)”，比如type A int，类型A是定义的类型</code><!-- raw HTML omitted -->
     <code>3.通过“类型定义”创建出来的类型的别名也是“定义的类型(Defined Types)”，比如type B=A，类型B也是定义的类型</code><!-- raw HTML omitted --></p>
<p>**非定义的类型(Non-Defined Types)**<!-- raw HTML omitted -->
     <code>1.复合数据类型是“非定义的类型(Non-Defined Types)”，比如slice，map，channel和struct定义的结构体类型。</code><!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span> []<span style="color:#66d9ef">string</span> <span style="color:#75715e">//[]string是切片，属于复合数据类型，所以[]string是“非定义的类型(Non-Defined Types)”。 但是A是通过“类型定义”创建出来的类型，属于“定义的类型(Defined Types)”，符合“定义的类型(Defined Types)”的第2点。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">B</span> = <span style="color:#a6e22e">A</span> <span style="color:#75715e">//B是通过“类型定义”创建出来的类型A的别名，所以B也是“定义的类型(Defined Types)”,符合“定义的类型(Defined Types)”的第3点。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">C</span> = []<span style="color:#66d9ef">string</span> <span style="color:#75715e">//[]string是切片，属于复合数据类型，所以[]string是**非定义的类型(Non-Defined Types)**。C不符合“定义的类型(Defined Types)”的3点定义，C是“非定义的类型(Non-Defined Types)”。
</span></code></pre></div><p>Pointer指针: 类型T的指针类型为<em>T，T是</em>T的基础类型，*T类型的变量我们称之为指针，指针存储的是地址。 //adm</p>
<h2 id="13-pointer">1.3 pointer</h2>
<p>基础类型的变量可以通过&amp;符号来得到变量的内存地址</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">100</span>
println(<span style="color:#e6db74">&#34;Value of a:&#34;</span>, <span style="color:#a6e22e">a</span>)
println(<span style="color:#e6db74">&#34;Address of a:&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>)
</code></pre></div><p><code>Value of a: 100</code>
<code>Address of a: 0x41c7ac</code></p>
<p><a href="https://play.golang.org/p/UMN5EBhBMi0"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a> <!-- raw HTML omitted --></p>
<p>内建函数new(T)可以为*T类型的变量分配内存并返回这块内存的地址，比如<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> <span style="color:#75715e">//p 为*int类型的指针，*int的基础类型是int
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34;p: &#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
<span style="color:#a6e22e">p</span> = new(<span style="color:#66d9ef">int</span>) <span style="color:#75715e">//new(int)分配一块存储int型数值的内存，并返回这块内存的地址给p
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34;p: &#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</code></pre></div><p><code>p:  0x0 true</code>
<code>p:  0x41c7ac false</code></p>
<p><a href="https://play.golang.org/p/DaCmuO67au9"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a><!-- raw HTML omitted --></p>
<p>如下例子演示了指针和整型变量的关系</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">100</span>
println(<span style="color:#e6db74">&#34;Value of a:&#34;</span>, <span style="color:#a6e22e">a</span>)
println(<span style="color:#e6db74">&#34;Address of a:&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pa</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
println()
println(<span style="color:#e6db74">&#34;Value of pa:&#34;</span>, <span style="color:#a6e22e">pa</span>)

<span style="color:#a6e22e">pa</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span> <span style="color:#75715e">//将变量a的地址赋给pa，pa存储的是变量a的地址，即pa指向变量a。
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34;Value of pa:&#34;</span>, <span style="color:#a6e22e">pa</span>)
println(<span style="color:#e6db74">&#34;Value pointed by pa:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">pa</span>) <span style="color:#75715e">//*pa表示取出pa存储地址上的数据，即a的值。
</span><span style="color:#75715e"></span>
<span style="color:#f92672">*</span><span style="color:#a6e22e">pa</span> = <span style="color:#ae81ff">200</span> <span style="color:#75715e">//*pa = 200指的是将200赋到pa所指向的地址上，pa存储的是变量a的地址，从而变量a的值从100变为了200
</span><span style="color:#75715e"></span>println()
println(<span style="color:#e6db74">&#34;Value of pa:&#34;</span>, <span style="color:#a6e22e">pa</span>)
println(<span style="color:#e6db74">&#34;Value pointed by pa:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">pa</span>)

<span style="color:#a6e22e">pa</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//将pa的值赋为nil，则pa不再指向变量a，pa的值变了，但变量a的地址和值均未变
</span><span style="color:#75715e"></span>println()
println(<span style="color:#e6db74">&#34;Value of pa:&#34;</span>, <span style="color:#a6e22e">pa</span>)
println(<span style="color:#e6db74">&#34;Value of a:&#34;</span>, <span style="color:#a6e22e">a</span>)
println(<span style="color:#e6db74">&#34;Address of a:&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>)
</code></pre></div><p><code>Value of a: 100</code><!-- raw HTML omitted -->
<code>Address of a: 0x41c7a4</code><!-- raw HTML omitted --></p>
<p><code>Value of pa: 0x0</code><!-- raw HTML omitted --></p>
<p><code>Value of pa: 0x41c7a4</code><!-- raw HTML omitted -->
<code>Value pointed by pa: 100</code><!-- raw HTML omitted --></p>
<p><code>Value of pa: 0x41c7a4</code><!-- raw HTML omitted -->
<code>Value pointed by pa: 200</code><!-- raw HTML omitted --></p>
<p><code>Value of pa: 0x0</code><!-- raw HTML omitted -->
<code>Value of a: 200</code><!-- raw HTML omitted -->
<code>Address of a: 0x41c7a4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/L81O1OBPYrS"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a><!-- raw HTML omitted --></p>
<p>指针类型转换</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DINT</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PINT</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PDINT</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DINT</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">200</span>
println(<span style="color:#e6db74">&#34;i:&#34;</span>, <span style="color:#a6e22e">i</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> = new(<span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">p</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>
println(<span style="color:#e6db74">&#34;p:&#34;</span>, <span style="color:#a6e22e">p</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">di</span> <span style="color:#a6e22e">DINT</span>
<span style="color:#75715e">//di = i //cannot use i (type int) as type DINT in assignment
</span><span style="color:#75715e"></span><span style="color:#a6e22e">di</span> = (<span style="color:#a6e22e">DINT</span>)(<span style="color:#a6e22e">i</span>) <span style="color:#75715e">//显示转换;非指针类型的定义类型(DINT)和基础类型(int)的变量不可以互相直接赋值，编译器无法使用隐式转换，代码里需要显示转换。
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34; i to  di:&#34;</span>, <span style="color:#a6e22e">di</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pi</span> <span style="color:#a6e22e">PINT</span>
<span style="color:#a6e22e">pi</span> = <span style="color:#a6e22e">p</span>         <span style="color:#75715e">//隐式转换;pi的类型演变是PINT--*int; p的类型是*int。*int到PINT之间没有其他类型，*int类型的变量p可以直接(隐式转换)赋给PINT类型的变量pi。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">pi</span> = (<span style="color:#a6e22e">PINT</span>)(<span style="color:#a6e22e">p</span>) <span style="color:#75715e">//显示转换;pi的类型演变是PINT--*int; p的类型是*int。*int到PINT之间没有其他类型，*int类型的变量p也可以显示转换赋给PINT类型的变量pi。
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34; p to  pi:&#34;</span>, <span style="color:#a6e22e">pi</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pdi</span> <span style="color:#a6e22e">PDINT</span>
<span style="color:#75715e">//pdi = p //cannot use p (type *int) as type PDINT in assignment
</span><span style="color:#75715e"></span><span style="color:#a6e22e">pdi</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">DINT</span>)(<span style="color:#a6e22e">p</span>)          <span style="color:#75715e">//显式+隐式转换;pdi的类型演变是PDINT--*DINT--*int; p的类型是*int。*int到PDINT之间有一个*DINT类型，*int类型的变量p需要先显示转换成*DINT类型，*DINT到PINT之间没有其他类型，*DINT类型的变量p通过隐式转换成PINT，再赋给PINT类型的变量pi。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">pdi</span> = (<span style="color:#a6e22e">PDINT</span>)((<span style="color:#f92672">*</span><span style="color:#a6e22e">DINT</span>)(<span style="color:#a6e22e">p</span>)) <span style="color:#75715e">//显示转换     ;pdi的类型演变是PDINT--*DINT--*int; p的类型是*int。*int到PDINT之间有一个*DINT类型，*int类型的变量p需要先显示转换成*DINT类型，*DINT到PINT之间没有其他类型，*DINT类型的变量p也可以显示转换成PINT，再赋给PINT类型的变量pi。
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34; p to pdi:&#34;</span>, <span style="color:#a6e22e">pdi</span>)

<span style="color:#75715e">//pdi = pi //cannot use pi (type PINT) as type PDINT in assignment;pi不能直接赋给pdi，因为pi和pdi是不同的类型
</span><span style="color:#75715e"></span><span style="color:#a6e22e">pdi</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">DINT</span>)((<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">pi</span>))          <span style="color:#75715e">//显式+隐式转换;pdi的类型演变是PDINT--*DINT--*int; pi的类型演变是PINT--*int。PINT类型的变量pi需要先显示转换回*int类型，然后再显示转换成*DINT类型，*DINT到PINT之间没有其他类型，*DINT类型的变量pi通过隐式转换成PDINT，再赋给PDINT类型的变量pdi。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">pdi</span> = (<span style="color:#a6e22e">PDINT</span>)((<span style="color:#f92672">*</span><span style="color:#a6e22e">DINT</span>)((<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">pi</span>))) <span style="color:#75715e">//显示转换     ;pdi的类型演变是PDINT--*DINT--*int; pi的类型演变是PINT--*int。PINT类型的变量pi需要先显示转换回*int类型，然后再显示转换成*DINT类型，*DINT到PINT之间没有其他类型，*DINT类型的变量pi也可以显示转换成PDINT，再赋给PDINT类型的变量pdi。
</span><span style="color:#75715e"></span>println(<span style="color:#e6db74">&#34;pi to pdi:&#34;</span>, <span style="color:#a6e22e">pdi</span>)
</code></pre></div><p><code>i: 200</code><!-- raw HTML omitted -->
<code>p: 0x41c7a4</code><!-- raw HTML omitted -->
<code> i to  di: 200</code><!-- raw HTML omitted -->
<code> p to  pi: 0x41c7a4</code><!-- raw HTML omitted -->
<code> p to pdi: 0x41c7a4</code><!-- raw HTML omitted -->
<code>pi to pdi: 0x41c7a4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/iMAxkg2sryh"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a><!-- raw HTML omitted --></p>
<p><strong>go指针与c指针的不同之处</strong><!-- raw HTML omitted -->
<code>*p++</code>与<code>*p--</code>在c语言中分别是将指针的值自加或自减，而在go语言中则指的是将p指针指向的值自加或自减<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> = new(<span style="color:#66d9ef">int</span>)
println(<span style="color:#e6db74">&#34;p addr:&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;p value:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">100</span>
println(<span style="color:#e6db74">&#34;p addr:&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;p value:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span><span style="color:#f92672">++</span>
println(<span style="color:#e6db74">&#34;p addr:&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;p value:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span><span style="color:#f92672">--</span>
println(<span style="color:#e6db74">&#34;p addr:&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;p value:&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
</code></pre></div><p><code>p addr: 0x41c7ac p value: 0</code><!-- raw HTML omitted -->
<code>p addr: 0x41c7ac p value: 100</code><!-- raw HTML omitted -->
<code>p addr: 0x41c7ac p value: 101</code><!-- raw HTML omitted -->
<code>p addr: 0x41c7ac p value: 100</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/UnSoFHk_z-E"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a><!-- raw HTML omitted --></p>
<p>c语言中被调函数里声明并定义的指针在被调函数返回时被释放，但go中有垃圾回收机制，被调函数中声明定义的指针可以返回到调用函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pointerTest</span>() <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> {
       	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> = new(<span style="color:#66d9ef">int</span>)
       	<span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span> = <span style="color:#ae81ff">123456789</span>
       	println(<span style="color:#e6db74">&#34;ptr:&#34;</span>, <span style="color:#a6e22e">ptr</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span>)
       	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ptr</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
       	<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pointerTest</span>()
       	println(<span style="color:#e6db74">&#34;ret:&#34;</span>, <span style="color:#a6e22e">ret</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">ret</span>)
}
</code></pre></div><p><code>ptr: 0x41c7a4 123456789</code><!-- raw HTML omitted -->
<code>ret: 0x41c7a4 123456789</code></p>
<p><a href="https://play.golang.org/p/GSYweaHYZeG"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a><!-- raw HTML omitted --></p>
<h2 id="14-rune">1.4 rune</h2>
<p>rune类型: rune类型的变量用于存储Unicode字符的编码 //adm</p>
<p>rune和int32是同一种数据类型，用于存储<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8"><strong>Unicode字符</strong></a>的编码<!-- raw HTML omitted -->
rune 的字面量需要用单引号<code>''</code>引起来, 单引号<code>''</code>中的内容可以是以下6种中的一种：<!-- raw HTML omitted -->
<code>1. 除换行符U+000A和未转意的单引号'之外的任意Unicode字符</code><!-- raw HTML omitted -->
<code>2. \后面跟3位8进制数</code><!-- raw HTML omitted -->
<code>3. \x后面跟2位16进制数</code><!-- raw HTML omitted -->
<code>4. \u后面跟4位16进制数</code><!-- raw HTML omitted -->
<code>5. \U后面跟8位16进制数</code><!-- raw HTML omitted -->
<code>6. 以下任意一个转意字符:</code><!-- raw HTML omitted -->
     <code>\a   U+0007 alert or bell</code><!-- raw HTML omitted -->
     <code>\b   U+0008 backspace</code><!-- raw HTML omitted -->
     <code>\f   U+000C form feed</code><!-- raw HTML omitted -->
     <code>\n   U+000A line feed or newline</code><!-- raw HTML omitted -->
     <code>\r   U+000D carriage return</code><!-- raw HTML omitted -->
     <code>\t   U+0009 horizontal tab</code><!-- raw HTML omitted -->
     <code>\v   U+000b vertical tab</code><!-- raw HTML omitted -->
     <code>\\   U+005c backslash</code><!-- raw HTML omitted -->
     <code>\'   U+0027 single quote  (valid escape only within rune literals)</code><!-- raw HTML omitted -->
     <code>\&quot;   U+0022 double quote  (valid escape only within string literals)</code><!-- raw HTML omitted --><!-- raw HTML omitted -->
以Unicode编码U+0061为例，它对应的十进制数是97，对应的字符是字母a。<!-- raw HTML omitted -->
以上1-5 rune字面量的的表示方式如下，可以看到5种赋值的方法，最终打印出来的结果均是97<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>

<span style="color:#a6e22e">r</span> = <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#75715e">//字面量&#39;a&#39;
</span><span style="color:#75715e"></span>println(<span style="color:#a6e22e">r</span>)

<span style="color:#a6e22e">r</span> = <span style="color:#e6db74">&#39;\141&#39;</span> <span style="color:#75715e">//3位8 进制的字面量表示为\141
</span><span style="color:#75715e"></span>println(<span style="color:#a6e22e">r</span>)

<span style="color:#a6e22e">r</span> = <span style="color:#e6db74">&#39;\x61&#39;</span> <span style="color:#75715e">//2位16进制的字面量表示为\x61
</span><span style="color:#75715e"></span>println(<span style="color:#a6e22e">r</span>)

<span style="color:#a6e22e">r</span> = <span style="color:#e6db74">&#39;\u0061&#39;</span> <span style="color:#75715e">//4位16进制的字面量表示为\u0061
</span><span style="color:#75715e"></span>println(<span style="color:#a6e22e">r</span>)

<span style="color:#a6e22e">r</span> = <span style="color:#e6db74">&#39;\U00000061&#39;</span> <span style="color:#75715e">//8位16进制的字面量表示为\U00000061
</span><span style="color:#75715e"></span>println(<span style="color:#a6e22e">r</span>)
</code></pre></div><p><code>97</code><!-- raw HTML omitted -->
<code>97</code><!-- raw HTML omitted -->
<code>97</code><!-- raw HTML omitted -->
<code>97</code><!-- raw HTML omitted -->
<code>97</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/IMeSrjLnGAz"><strong>🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 P L A Y A R O U N D 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓 🍋 🥝 🍓</strong></a></p>
<h2 id="15-bool">1.5 bool</h2>
<p>bool类型: //adm</p>
<h2 id="16-byte">1.6 byte</h2>
<p>byte类型: byte是uint8的别名，可以将byte和uint8看作同一种数据类型 //adm</p>
<h2 id="17-uintptr">1.7 uintptr</h2>
<p>uintptr类型:  //adm</p>
<h2 id="18-string">1.8 string</h2>
<p>string类型:  //adm</p>
<h2 id="19-float">1.9 float</h2>
<p>float32与float64类型:  //adm</p>
<p>浮点型的字面量由一个整数部分，一个小数点部分，一个小数部分和一个exponent部分，某些部分可以省略。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">1.23</span>
<span style="color:#ae81ff">01.23</span> <span style="color:#75715e">// == 1.23
</span><span style="color:#75715e"></span><span style="color:#ae81ff">.23</span>
<span style="color:#ae81ff">1.</span>
<span style="color:#75715e">// A &#34;e&#34; or &#34;E&#34; starts the exponent part.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1.23e2</span>  <span style="color:#75715e">// == 123.0
</span><span style="color:#75715e"></span><span style="color:#ae81ff">123E2</span>   <span style="color:#75715e">// == 12300.0
</span><span style="color:#75715e"></span><span style="color:#ae81ff">123.</span><span style="color:#a6e22e">E</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> <span style="color:#75715e">// == 12300.0
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1e-1</span>    <span style="color:#75715e">// == 0.1
</span><span style="color:#75715e"></span><span style="color:#ae81ff">.1e0</span>    <span style="color:#75715e">// == 0.1
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0e+5</span>    <span style="color:#75715e">// == 0.0
</span></code></pre></div><h2 id="110-complex">1.10 complex</h2>
<p>complex64与complex128类型:  //adm</p>
<h1 id="2-">2. 数组</h1>
<h2 id="21-">2.1 数组声明与初始化</h2>
<p>声明一个5个元素的数组, 每个元素为int型整数，并为这5个元素赋值 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">10</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">20</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">30</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">40</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">50</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
</code></pre></div><p><code>len: 5 array: [10 20 30 40 50]</code></p>
<p><a href="https://play.golang.org/p/uG3hTbW6E_X"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>声明一个5个元素的数组, 每个元素为int型整数，并初始化 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">50</span>}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
</code></pre></div><p><code>len: 5 array: [10 20 30 40 50]</code></p>
<p><a href="https://play.golang.org/p/GNFqU0yYVy8"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>[&hellip;] 根据初始化元素的数量来确定数组的长度 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">70</span>, <span style="color:#ae81ff">80</span>}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
</code></pre></div><p><code>len: 8 array: [10 20 30 40 50 60 70 80]</code></p>
<p><a href="https://play.golang.org/p/tQZZJC4iBsD"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>声明一个数组，并将第0个和第10个元素初始化为50 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>: <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">10</span>: <span style="color:#ae81ff">50</span>}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
</code></pre></div><p><code>len: 11 array: [50 0 0 0 0 0 0 0 0 0 50]</code></p>
<p><a href="https://play.golang.org/p/g5ThOlHRmus"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<h2 id="22-">2.2 数组元素为指针</h2>
<p>声明一个5个元素的数组, 每个元素为*int整型指针，并用new(int)为这5个元素分配整型指针地址 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array</span> [<span style="color:#ae81ff">5</span>]<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;declared array:&#34;</span>, <span style="color:#a6e22e">array</span>)
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>] = new(<span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>] = new(<span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">2</span>] = new(<span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">3</span>] = new(<span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">4</span>] = new(<span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;assigned array:&#34;</span>, <span style="color:#a6e22e">array</span>)
</code></pre></div><p><code>declared array: [&lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;]</code><!-- raw HTML omitted -->
<code>assigned array: [0x416030 0x416034 0x416038 0x41603c 0x416040]</code></p>
<p><a href="https://play.golang.org/p/_rM2W2QkOsY"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>声明一个5个元素的数组, 每个元素为*int整型指针，并初始化 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>{new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>)}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;initial array:&#34;</span>, <span style="color:#a6e22e">array</span>)
</code></pre></div><p><code>initial array: [0x416020 0x416024 0x416028 0x41602c 0x416030]</code></p>
<p><a href="https://play.golang.org/p/_b5U8Ps2t6M"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>&amp;array[0]，array[0] 与 *array[0] //adm</p>
<p>&amp;array[0]表示数组元素array[0]的地址<!-- raw HTML omitted -->
array[0]存储的是指针的地址<!-- raw HTML omitted -->
*array[0]表示array[0]指针地址指向的数据<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">10</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&amp;array[0] =&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#34;array[0] =&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#34;*array[0] =&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>])

<span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">20</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&amp;array[1] =&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;array[1] =&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;*array[1] =&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>])

<span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">30</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&amp;array[2] =&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;array[2] =&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;*array[2] =&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">2</span>])

<span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">40</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&amp;array[3] =&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">3</span>], <span style="color:#e6db74">&#34;array[3] =&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">3</span>], <span style="color:#e6db74">&#34;*array[3] =&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">3</span>])

<span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">50</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;&amp;array[4] =&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">4</span>], <span style="color:#e6db74">&#34;array[4] =&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">4</span>], <span style="color:#e6db74">&#34;*array[4] =&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">4</span>])
</code></pre></div><p><code>&amp;array[0] = 0x442260 array[0] = 0x416020 *array[0] = 10</code><!-- raw HTML omitted -->
<code>&amp;array[1] = 0x442264 array[1] = 0x416024 *array[1] = 20</code><!-- raw HTML omitted -->
<code>&amp;array[2] = 0x442268 array[2] = 0x416028 *array[2] = 30</code><!-- raw HTML omitted -->
<code>&amp;array[3] = 0x44226c array[3] = 0x41602c *array[3] = 40</code><!-- raw HTML omitted -->
<code>&amp;array[4] = 0x442270 array[4] = 0x416030 *array[4] = 50</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/L9qH_77gX6G"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<h2 id="23-">2.3 数组互相赋值</h2>
<p>go语言支持将一个数组所有元素的值赋给另一个数组，前提是这2个数组要具有相同的<strong>类型</strong>和<strong>长度</strong></p>
<p>数组元素为整型类型时，将array2中5个元素的值拷贝到array1 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array1</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;declared array1:&#34;</span>, <span style="color:#a6e22e">array1</span>)

<span style="color:#a6e22e">array2</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">50</span>}
<span style="color:#a6e22e">array1</span> = <span style="color:#a6e22e">array2</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;assigned array1:&#34;</span>, <span style="color:#a6e22e">array1</span>)

</code></pre></div><p><code>declared array1: [0 0 0 0 0]</code><!-- raw HTML omitted -->
<code>assigned array1: [10 20 30 40 50]</code></p>
<p><a href="https://play.golang.org/p/YbSZmdgt_Ob"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>数组元素为字符串类型时，将array2中5个元素的值拷贝到array1 //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array1</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array2</span> = [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;desk&#34;</span>, <span style="color:#e6db74">&#34;pencil&#34;</span>, <span style="color:#e6db74">&#34;ruler&#34;</span>, <span style="color:#e6db74">&#34;ink&#34;</span>, <span style="color:#e6db74">&#34;book&#34;</span>}

<span style="color:#a6e22e">array1</span> = <span style="color:#a6e22e">array2</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array1):&#34;</span>, len(<span style="color:#a6e22e">array1</span>), <span style="color:#e6db74">&#34; array1   :&#34;</span>, <span style="color:#a6e22e">array1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array2):&#34;</span>, len(<span style="color:#a6e22e">array2</span>), <span style="color:#e6db74">&#34; array2   :&#34;</span>, <span style="color:#a6e22e">array2</span>)

</code></pre></div><p><code>len(array1): 5  array1   : [desk pencil ruler ink book]</code><!-- raw HTML omitted -->
<code>len(array2): 5  array2   : [desk pencil ruler ink book]</code></p>
<p><a href="https://play.golang.org/p/HuHXZ-c0gv5"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>数组元素为指针类型时，将array2中5个元素的值（指针地址)拷贝到array1  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array1</span> [<span style="color:#ae81ff">5</span>]<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;declared array1:&#34;</span>, <span style="color:#a6e22e">array1</span>)

<span style="color:#a6e22e">array2</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>{new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>), new(<span style="color:#66d9ef">int</span>)}
<span style="color:#a6e22e">array1</span> = <span style="color:#a6e22e">array2</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;assigned array1:&#34;</span>, <span style="color:#a6e22e">array1</span>)
</code></pre></div><p><code>declared array1: [&lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;]</code><!-- raw HTML omitted -->
<code>assigned array1: [0x416030 0x416034 0x416038 0x41603c 0x416040]</code></p>
<p><a href="https://play.golang.org/p/rG8UHTVYYNP"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<h2 id="24-">2.4 二维数组</h2>
<p>一维数组,  指的是一行多列的数组。比如var array [5]int,       是1行5列的一维数组。<!-- raw HTML omitted -->
二维数组，指的是多行多列的数组。比如var array [2][5]int，是2行5列的二维数组。</p>
<p>声明一个2行5列的二维数组，每个元素为int型整数，并初始化每个元素  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span> {{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">14</span>},{<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">24</span>}}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array):&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array[0]):&#34;</span>, len(<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>]), <span style="color:#e6db74">&#34;array[0]:&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>])
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array[1]):&#34;</span>, len(<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>]), <span style="color:#e6db74">&#34;array[1]:&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>])
</code></pre></div><p><code>len(array): 2 array: [[10 11 12 13 14] [20 21 22 23 24]]</code><!-- raw HTML omitted -->
<code>len(array[0]): 5 array[0]: [10 11 12 13 14]</code><!-- raw HTML omitted -->
<code>len(array[1]): 5 array[1]: [20 21 22 23 24]</code></p>
<p><a href="https://play.golang.org/p/bJqnRfeWlvK"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a><!-- raw HTML omitted --></p>
<p>声明一个2行5列的二维数组，每个元素为int型整数，并初始化第2行第3个元素  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>: {<span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">22</span>}}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array):&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array[0]):&#34;</span>, len(<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>]), <span style="color:#e6db74">&#34;array[0]:&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>])
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array[1]):&#34;</span>, len(<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>]), <span style="color:#e6db74">&#34;array[1]:&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>])
</code></pre></div><p><code>len(array): 2 array: [[0 0 0 0 0] [0 0 22 0 0]]</code><!-- raw HTML omitted -->
<code>len(array[0]): 5 array[0]: [0 0 0 0 0]</code><!-- raw HTML omitted -->
<code>len(array[1]): 5 array[1]: [0 0 22 0 0]</code></p>
<p><a href="https://play.golang.org/p/ue7to0hPJVP"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a><!-- raw HTML omitted --></p>
<p>声明一个2行5列的二维数组，每个元素为int型整数，并依次为每个元素赋值  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">10</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">11</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">12</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">13</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">14</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">20</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">21</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">22</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">23</span>
<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">24</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array):&#34;</span>, len(<span style="color:#a6e22e">array</span>), <span style="color:#e6db74">&#34;array:&#34;</span>, <span style="color:#a6e22e">array</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array[0]):&#34;</span>, len(<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>]), <span style="color:#e6db74">&#34;array[0]:&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">0</span>])
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array[1]):&#34;</span>, len(<span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>]), <span style="color:#e6db74">&#34;array[1]:&#34;</span>, <span style="color:#a6e22e">array</span>[<span style="color:#ae81ff">1</span>])
</code></pre></div><p><code>len(array): 2 array: [[10 11 12 13 14] [20 21 22 23 24]]</code><!-- raw HTML omitted -->
<code>len(array[0]): 5 array[0]: [10 11 12 13 14]</code><!-- raw HTML omitted -->
<code>len(array[1]): 5 array[1]: [20 21 22 23 24]</code></p>
<p><a href="https://play.golang.org/p/F-nSACHOGJn"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<p>二维数组互相赋值  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array1</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">array2</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>

<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">10</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">11</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">12</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">13</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">14</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">20</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">21</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">22</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">23</span>
<span style="color:#a6e22e">array2</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">24</span>

<span style="color:#a6e22e">array1</span> = <span style="color:#a6e22e">array2</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array1):&#34;</span>, len(<span style="color:#a6e22e">array1</span>), <span style="color:#e6db74">&#34;array1:&#34;</span>, <span style="color:#a6e22e">array1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;len(array2):&#34;</span>, len(<span style="color:#a6e22e">array2</span>), <span style="color:#e6db74">&#34;array2:&#34;</span>, <span style="color:#a6e22e">array2</span>)
</code></pre></div><p><code>len(array1): 2 array1: [[10 11 12 13 14] [20 21 22 23 24]]</code><!-- raw HTML omitted -->
<code>len(array2): 2 array2: [[10 11 12 13 14] [20 21 22 23 24]]</code></p>
<p><a href="https://play.golang.org/p/z82JDO2xVD4"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">array</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">14</span>}, {<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">24</span>}}
	<span style="color:#a6e22e">test1</span>(<span style="color:#a6e22e">array</span>)
	<span style="color:#a6e22e">test2</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">array</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test1</span>(<span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>) { <span style="color:#75715e">//test1参数传递的是整个二维数组
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;test1 a :&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#e6db74">&#34;len(a):&#34;</span>, len(<span style="color:#a6e22e">a</span>), <span style="color:#e6db74">&#34;sizeof(a):&#34;</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">a</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test2</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>) { <span style="color:#75715e">//test2参数传递的是二维数组的指针
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;test2 a:&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#e6db74">&#34;len(a):&#34;</span>, len(<span style="color:#a6e22e">a</span>), <span style="color:#e6db74">&#34;sizeof(a):&#34;</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">a</span>))
}
</code></pre></div><p><code>test1 a : [[10 11 12 13 14] [20 21 22 23 24]] len(a): 2 sizeof(a): 40</code><!-- raw HTML omitted -->
<code>test2 a: &amp;[[10 11 12 13 14] [20 21 22 23 24]] len(a): 2 sizeof(a): 4</code><!-- raw HTML omitted --></p>
<p>可以看到test2的参数a（传递的是二维数组的指针）只占4个字节，比test1的参数a（传递的整个二维数组）的40个字节要节省很多内存空间。<!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/QeFy6wxv7qW"><strong>🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 P L A Y A R O U N D 🥤  🍔 🍟 🥤 🍔 🍟 🥤 🍔 🍟 🥤 🍔</strong></a></p>
<h1 id="3-">3. 切片</h1>
<p>切片是一个结构体，这个结构体包含了一个指向数组的指针elements，切片当前可用数组元素的个数length，和切片最多可用数组元素的个数capacity.<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_slice</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">elements</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// referencing underlying elements
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">len</span>      <span style="color:#66d9ef">int</span>            <span style="color:#75715e">// length
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cap</span>      <span style="color:#66d9ef">int</span>            <span style="color:#75715e">// capacity
</span><span style="color:#75715e"></span>}
</code></pre></div><p>切片相对于数组的好处是切片可以自动增长和缩小空间。<!-- raw HTML omitted --></p>
<h2 id="31-">3.1 切片声明和初始化</h2>
<p>「nil slice声明方式一」用var声明的切片变量是nil slice。  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">//or var s []int = nil
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s is nil?&#34;</span>, <span style="color:#a6e22e">s</span><span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s is nil? true</code><!-- raw HTML omitted -->
<code>s []int(nil)</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x0 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p>用%#v打印s时表示用go的语法格式来表示变量s。<!-- raw HTML omitted -->
用%p打印&amp;s时表示的是切片变量s的首地址。<!-- raw HTML omitted -->
用%p打印s时表示的是切片中elements的值，即切片数组的首地址。<!-- raw HTML omitted -->
当elements为0值时(指针elements的0值用nil表示)，这种切片称作nil slice。<!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/WxZXt2BMEFP"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>「nil slice声明方式二」用 := 简短声明一个切片并用(nil)初始化的变量是nil slice。  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []int(<span style="color:#66d9ef">nil</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s is nil?&#34;</span>, <span style="color:#a6e22e">s</span><span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s is nil? true</code><!-- raw HTML omitted -->
<code>s []int(nil)</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x0 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p>s := []int(nil) 和 var s []int 声明的切片打印结果一样，这两种方式均是声明一个nil slice。</p>
<p><a href="https://play.golang.org/p/te0FGkHZJGN"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>「blank slice声明方式一」 用 := 简短声明一个切片并用{ }初始化的变量是blank slice。  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s is nil?&#34;</span>, <span style="color:#a6e22e">s</span><span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s is nil? false</code><!-- raw HTML omitted -->
<code>s []int{}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x1c4c64 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p>用{}初始化切片变量s时，elements不是0值(与nil slice的差异)，它含有内存的地址值，但地址上的值为空(0值)，所以这种切片称作blank slice空切片。</p>
<p><a href="https://play.golang.org/p/YMt8Pdj5a7H"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>「blank slice声明方式二」 用 make 创建len和cap均为0的切片变量是blank silce。  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s is nil?&#34;</span>, <span style="color:#a6e22e">s</span><span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s is nil? false</code><!-- raw HTML omitted -->
<code>s []int{}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x1c4c64 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p>s := make([]int, 0) 和 s := []int{} 声明的切片打印结果一样，这两种方式均是创建一个blank slice。</p>
<p><a href="https://play.golang.org/p/z-PYfXziItX"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>直接初始化切片  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;pen&#34;</span>, <span style="color:#e6db74">&#34;ink&#34;</span>, <span style="color:#e6db74">&#34;paper&#34;</span>, <span style="color:#e6db74">&#34;eraser&#34;</span>, <span style="color:#e6db74">&#34;bag&#34;</span>}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s []string{&quot;pen&quot;, &quot;ink&quot;, &quot;paper&quot;, &quot;eraser&quot;, &quot;bag&quot;}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x430150 len: 5 cap: 5</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/K8hjqAlFr6c"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>初始化切片的第4个元素  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#ae81ff">4</span>: <span style="color:#e6db74">&#34;bag&#34;</span>}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s []string{&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;bag&quot;}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x430150 len: 5 cap: 5</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/hzXI06zpVYd"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h2 id="32-make">3.2 用make创建切片</h2>
<p>在「blank slice声明方式二」时我们用s := make([]int, 0)创建了一个切片数组长度为0的切片s，称作blank slice空切片。<!-- raw HTML omitted -->
make是go语言的内置函数，可以为slice，map和channel分配空间，这里我们首先了解make是如何创建slice的。</p>
<blockquote>
<p>func make(t Type, size &hellip;IntegerType) Type</p>
</blockquote>
<p>make的第1个参数t是Type类型的变量，它的返回类型是和t类型一样的Type类型，不是一个指针。<!-- raw HTML omitted -->
对于切片来说，如果只填第1个整型参数size， 则切片的len和cap的大小均为size。<!-- raw HTML omitted -->
如果再填第2个整型参数(make是可变参的函数)，则第一个整型参数表示切片的len大小，第二个整型参数表示切片的cap大小。</p>
<p>用make给nil slice分配数组空间, len == cap  //adm</p>
<p>nil slice是不能直接进行进行赋值的，因为系统没有为nil slice分配对应的数组（elements为nil）。<!-- raw HTML omitted -->
要为nil slice赋值的话需要使用make为slice分配数组空间，然后再赋值。
如下例子演示了slice的len与cap相等时的情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">//or var s []int = nil
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))

<span style="color:#a6e22e">s</span> = make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))

<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">2</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">3</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">5</span>

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
</code></pre></div><p><code>s []int(nil)</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x0 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p><code>s []int{0, 0, 0, 0, 0}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x450020 len: 5 cap: 5</code><!-- raw HTML omitted --></p>
<p><code>s []int{1, 2, 3, 4, 5}</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/wgDX8PLINU-"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>用make给nil slice分配数组空间, len != cap  //adm</p>
<p>如下例子演示了slice的len与cap不相等时的情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span> []int(<span style="color:#66d9ef">nil</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))

<span style="color:#a6e22e">s</span> = make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))

<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">2</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">3</span>
<span style="color:#75715e">//s[3]不予赋值，因为切片s一共有4个数组元素可以访问，s[3]默认为0
</span><span style="color:#75715e"></span><span style="color:#75715e">//s[4]不能赋值，因为切片s一共有4个数组元素可以访问，给s[4]赋值，会导致编译错误
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
</code></pre></div><p><code>s []int(nil)</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x0 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p><code>s []int{0, 0, 0, 0}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x450020 len: 4 cap: 5</code><!-- raw HTML omitted --></p>
<p><code>s []int{1, 2, 3, 0}</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/x_eSDliV6Mx"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>用make创建切片  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)

<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">2</span>
<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">3</span>

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
</code></pre></div><p><code>s []int{1, 2, 3, 0}</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/ORU4Uo2gOp7"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h2 id="33-append">3.3 用append附加切片</h2>
<blockquote>
<p>func append(slice []Type, elems &hellip;Type) []Type</p>
</blockquote>
<p>append函数用于将新的元素或切片附加到切片的末尾。<!-- raw HTML omitted -->
如果切片的容量足够容纳新的数据，则新元素或切片将会被附加到切片的末尾;<!-- raw HTML omitted -->
如果切片的容量不足以容纳新的元素或切片，append函数将会重新分配一个新的切片用于存储原数据和新附加的数据或切片：<!-- raw HTML omitted -->
如果原来切片的容量小于1000，新的切片容量将会增长到原来的2倍，<!-- raw HTML omitted -->
如果原来切片的容量大于1000，新的切片容量将会增长到原来的1.25倍。<!-- raw HTML omitted --></p>
<p>给blank silce附加元素和切片  //adm</p>
<blockquote>
<p>使用append给切片附加元素和切片的使用方式为：<!-- raw HTML omitted -->
slice = append(slice, elem1, elem2)<!-- raw HTML omitted -->
slice = append(slice, anotherSlice&hellip;)</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{} <span style="color:#75715e">//or s := make([]int, 0)
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))

<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))

<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s1</span><span style="color:#f92672">...</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s array header address(elements): %p len: %d cap: %d\n\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</code></pre></div><p><code>s []int{}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x1c4c64 len: 0 cap: 0</code><!-- raw HTML omitted --></p>
<p><code>s []int{1, 2, 3}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x414040 len: 3 cap: 4</code><!-- raw HTML omitted --></p>
<p><code>s []int{1, 2, 3, 7, 8, 9}</code><!-- raw HTML omitted -->
<code>s header address: 0x40a0e0</code><!-- raw HTML omitted -->
<code>s array header address(elements): 0x450020 len: 6 cap: 8</code><!-- raw HTML omitted --></p>
<p>第一段打印结果：此时声明的切片变量s为blank slice空切片, elements为0x1c4c64, len和cap为0。<!-- raw HTML omitted -->
第二段打印结果：向切片s append数字1, 2, 3时，append函数为切片分配新的数组空间，<!-- raw HTML omitted -->
                             
切片数组首地址变为0x414040, 容量从0增加到4（以2的幂为基数），因为添加<!-- raw HTML omitted -->
                             
了3个数据，所以length为3。<!-- raw HTML omitted -->
第三段打印结果：继续向切片s append新的切片s1时(注意s1后面的&hellip;不能省)，原来的切片数组<!-- raw HTML omitted -->
                             
(0x414040)容量为2，已不足以容纳新的切片s1的3个元素，所以append函数为<!-- raw HTML omitted -->
                             
切片s重新分配了数组(0x450020)，容量从4增长到8并将原来数组(0x414040)的<!-- raw HTML omitted -->
                             
数据拷贝到新的数组(0x450020)里，然后将s1的元素附加s的末尾，s的len变为6。<!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/Ut4ZUVlIgFj"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>append函数还支持将字符串附加到byte类型的切片上  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> append([]byte(<span style="color:#e6db74">&#34;hello &#34;</span>), <span style="color:#e6db74">&#34;world&#34;</span><span style="color:#f92672">...</span>)

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;elements:%06p, capacity:%d, length:%d, slice: %s\n&#34;</span>, <span style="color:#a6e22e">slice</span>, len(<span style="color:#a6e22e">slice</span>), cap(<span style="color:#a6e22e">slice</span>), <span style="color:#a6e22e">slice</span>)
</code></pre></div><p><code>elements:0x414030, capacity:11, length:16, slice: hello world</code></p>
<p><a href="https://play.golang.org/p/PGxm3M5r7bV"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h2 id="34-copy">3.4 用copy拷贝切片</h2>
<p>copy函数的原型如下，它支持将src切片拷贝到dst切片，同样支持将字符串的字节拷贝到byte的切片中，src和dst可以重叠。<!-- raw HTML omitted -->
copy函数返回拷贝元素的数量，拷贝元素的数量是src或dst切片len的最小值。</p>
<blockquote>
<p>func copy(dst, src []Type) int</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)
<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">15</span>)
<span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}
<span style="color:#a6e22e">s4</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">5</span>)

<span style="color:#a6e22e">n1</span> <span style="color:#f92672">:=</span> copy(<span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">s3</span>[:])        <span style="color:#75715e">//s1 len 小于 s3 len
</span><span style="color:#75715e"></span><span style="color:#a6e22e">n2</span> <span style="color:#f92672">:=</span> copy(<span style="color:#a6e22e">s2</span>, <span style="color:#a6e22e">s3</span>[:])        <span style="color:#75715e">//s2 len 大于 s3 len
</span><span style="color:#75715e"></span><span style="color:#a6e22e">n3</span> <span style="color:#f92672">:=</span> copy(<span style="color:#a6e22e">s3</span>[<span style="color:#ae81ff">0</span>:], <span style="color:#a6e22e">s3</span>[<span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">9</span>])  <span style="color:#75715e">//s3 重叠拷贝
</span><span style="color:#75715e"></span><span style="color:#a6e22e">n4</span> <span style="color:#f92672">:=</span> copy(<span style="color:#a6e22e">s4</span>, <span style="color:#e6db74">&#34;blackwhite&#34;</span>) <span style="color:#75715e">//将字符串拷贝到byte切片
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;n1:&#34;</span>, <span style="color:#a6e22e">n1</span>, <span style="color:#e6db74">&#34;s1:&#34;</span>, <span style="color:#a6e22e">s1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;n2:&#34;</span>, <span style="color:#a6e22e">n2</span>, <span style="color:#e6db74">&#34;s2:&#34;</span>, <span style="color:#a6e22e">s2</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;n3:&#34;</span>, <span style="color:#a6e22e">n3</span>, <span style="color:#e6db74">&#34;s3:&#34;</span>, <span style="color:#a6e22e">s3</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n4: %d s4: %s\n&#34;</span>, <span style="color:#a6e22e">n4</span>, <span style="color:#a6e22e">s4</span>)
</code></pre></div><p><code>n1: 5 s1: [1 2 3 4 5]</code><!-- raw HTML omitted -->
<code>n2: 9 s2: [1 2 3 4 5 6 7 8 9 0 0 0 0 0 0]</code><!-- raw HTML omitted -->
<code>n3: 4 s3: [6 7 8 9 5 6 7 8 9]</code><!-- raw HTML omitted -->
<code>n4: 5 s4: black</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/tnTRpLAxv2K"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h2 id="35-">3.5 遍历切片</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;zero&#34;</span>, <span style="color:#e6db74">&#34;one&#34;</span>, <span style="color:#e6db74">&#34;two&#34;</span>, <span style="color:#e6db74">&#34;three&#34;</span>, <span style="color:#e6db74">&#34;four&#34;</span>, <span style="color:#e6db74">&#34;five&#34;</span>, <span style="color:#e6db74">&#34;six&#34;</span>, <span style="color:#e6db74">&#34;seven&#34;</span>, <span style="color:#e6db74">&#34;eight&#34;</span>}

<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
}
</code></pre></div><p><code>0 zero</code><!-- raw HTML omitted -->
<code>1 one</code><!-- raw HTML omitted -->
<code>2 two</code><!-- raw HTML omitted -->
<code>3 three</code><!-- raw HTML omitted -->
<code>4 four</code><!-- raw HTML omitted -->
<code>5 five</code><!-- raw HTML omitted -->
<code>6 six</code><!-- raw HTML omitted -->
<code>7 seven</code><!-- raw HTML omitted -->
<code>8 eight</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/NcqJAx8keKk"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h2 id="36-">3.6 划分切片</h2>
<p>在切片基础上创建切片  //adm</p>
<blockquote>
<ol>
<li>对于底层数组容量为 c 的slice[i:j]切片来说:<!-- raw HTML omitted -->
slice的切片长度是j - i<!-- raw HTML omitted -->
slice的切片容量是c - i<!-- raw HTML omitted --></li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>对于底层数组容量为 k 的slice[i:j:k]切片来说:<!-- raw HTML omitted -->
slice的切片长度是j - i<!-- raw HTML omitted -->
slice的切片容量是k - i<!-- raw HTML omitted --></li>
</ol>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">slice1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;pen&#34;</span>, <span style="color:#e6db74">&#34;ink&#34;</span>, <span style="color:#e6db74">&#34;paper&#34;</span>, <span style="color:#e6db74">&#34;eraser&#34;</span>, <span style="color:#e6db74">&#34;bag&#34;</span>}
<span style="color:#a6e22e">slice2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">slice1</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]
<span style="color:#a6e22e">slice3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">slice1</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">4</span>]
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice1</span>, len(<span style="color:#a6e22e">slice1</span>), cap(<span style="color:#a6e22e">slice1</span>))
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice2</span>, len(<span style="color:#a6e22e">slice2</span>), cap(<span style="color:#a6e22e">slice2</span>))
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice3</span>, len(<span style="color:#a6e22e">slice3</span>), cap(<span style="color:#a6e22e">slice3</span>))
</code></pre></div><p><code>[pen ink paper eraser bag] 5 5</code><!-- raw HTML omitted -->
<code>[ink paper] 2 4</code><!-- raw HTML omitted -->
<code>[ink paper] 2 3</code><!-- raw HTML omitted --></p>
<p>通过公式可以得出slice1的数组容量是5。
slice2的切片长度是 3 - 1 = 2， slice2的切片容量是 5 - 1 = 4.<!-- raw HTML omitted -->
slice3的切片长度是 3 - 1 = 2， slice2的切片容量是 4 - 1 = 3.<!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/YcLWUUnMm55"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>同一数组被多个切片引用时，修改某一切片元素的内容也会改变其他切片元素的内容  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">slice1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;pen&#34;</span>, <span style="color:#e6db74">&#34;ink&#34;</span>, <span style="color:#e6db74">&#34;paper&#34;</span>, <span style="color:#e6db74">&#34;eraser&#34;</span>, <span style="color:#e6db74">&#34;bag&#34;</span>}
<span style="color:#a6e22e">slice2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">slice1</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]
<span style="color:#a6e22e">slice2</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#e6db74">&#34;elephant&#34;</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice1</span>, len(<span style="color:#a6e22e">slice1</span>), cap(<span style="color:#a6e22e">slice1</span>))
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice2</span>, len(<span style="color:#a6e22e">slice2</span>), cap(<span style="color:#a6e22e">slice2</span>))
</code></pre></div><p><code>[pen ink elephant eraser bag] 5 5</code><!-- raw HTML omitted -->
<code>[ink elephant] 2 4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/w25gBzX7qt5"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h2 id="37-">3.7 二维切片</h2>
<p>二维切片的原理是切片成员变量len和cap均为2，elements指向的是一个长度为2，类型为_slice的数组  //adm</p>
<p>感受下面二维切片的地址表示方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>}}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice variable address: %p\n\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>) <span style="color:#75715e">//0x40a0e0：slice变量的首地址
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[0] header address: %p\n\n&#34;</span>, <span style="color:#a6e22e">slice</span>) <span style="color:#75715e">//0x43e260：二维切片里第0个切片成员slice[0]的首地址。
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[0] header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>])           <span style="color:#75715e">//0x43e260：二维切片里第0个切片成员slice[0]的首地址。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[0] array header address:  %p\n&#34;</span>, <span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>])     <span style="color:#75715e">//0x414020：slice[0]切片底层数组的首地址。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[0] array header address:  %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#75715e">//0x414020：slice[0]切片底层数组的首地址。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[0] array&#39;s addresses:     %p %p %p\n\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>], <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>], <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>])

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[1] header address: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">1</span>])           <span style="color:#75715e">//0x43e26c：二维切片里第1个切片成员slice[1]的首地址。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[1] array header address:  %p\n&#34;</span>, <span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">1</span>])     <span style="color:#75715e">//0x414030：slice[1]切片底层数组的首地址。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[1] array header address:  %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]) <span style="color:#75715e">//0x414030：slice[1]切片底层数组的首地址。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice[1] array&#39;s addresses:     %p %p %p\n\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>], <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>])
</code></pre></div><p><code>slice variable address: 0x40a0e0</code><!-- raw HTML omitted --></p>
<p><code>slice[0] header address: 0x43e260</code><!-- raw HTML omitted --></p>
<p><code>slice[0] header address: 0x43e260</code><!-- raw HTML omitted -->
<code>slice[0] array header address:  0x414020</code><!-- raw HTML omitted -->
<code>slice[0] array header address:  0x414020</code><!-- raw HTML omitted -->
<code>slice[0] array's addresses:     0x414020 0x414024 0x414028</code><!-- raw HTML omitted --></p>
<p><code>slice[1] header address: 0x43e26c</code><!-- raw HTML omitted -->
<code>slice[1] array header address:  0x414030</code><!-- raw HTML omitted -->
<code>slice[1] array header address:  0x414030</code><!-- raw HTML omitted -->
<code>slice[1] array's addresses:     0x414030 0x414034 0x414038</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/q8S9emkRT0_B"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<p>在函数间传递切片  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">14</span>}, {<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">24</span>}}
	<span style="color:#a6e22e">test1</span>(<span style="color:#a6e22e">slice</span>)
	<span style="color:#a6e22e">test2</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test1</span>(<span style="color:#a6e22e">a</span> [][]<span style="color:#66d9ef">int</span>) { <span style="color:#75715e">//test1参数传递的是整个二维切片
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//fmt.Println(&#34;test1 a :&#34;, a, &#34;len(a):&#34;, len(a), &#34;sizeof(a):&#34;, unsafe.Sizeof(a))
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;test2 a:&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#e6db74">&#34;sizeof(a):&#34;</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">a</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test2</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span>[][]<span style="color:#66d9ef">int</span>) { <span style="color:#75715e">//test2参数传递的是二维切片的指针
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//fmt.Println(&#34;test2 a:&#34;, a, &#34;len(a):&#34;, len(a), &#34;sizeof(a):&#34;, unsafe.Sizeof(a))
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;test2 a:&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#e6db74">&#34;sizeof(a):&#34;</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">a</span>))
}
</code></pre></div><p><code>test2 a: [[10 11 12 13 14] [20 21 22 23 24]] sizeof(a): 12</code><!-- raw HTML omitted -->
<code>test2 a: &amp;[[10 11 12 13 14] [20 21 22 23 24]] sizeof(a): 4</code><!-- raw HTML omitted --></p>
<p>可以看到test2的参数a（传递的是二维切片的指针）只占4个字节，比test1的参数a（传递的整个二维切片）的12个字节要节省很多内存空间。<!-- raw HTML omitted -->
test1的参数a占12个字节是因为切片的3个成员（elements，length和capacity）各占4各字节。 即使slice为二维切片，elements存储的是指向
一维切片slice[0]的首地址，elements作为指针，在32位平台上只占4个字节。</p>
<p>这段相似功能的代码也同样在<!-- raw HTML omitted --><code>在函数间传递数组</code><!-- raw HTML omitted -->的章节实现过，使用数组的输出结果如下：<!-- raw HTML omitted -->
<code>test1 a : [[10 11 12 13 14] [20 21 22 23 24]] len(a): 2 sizeof(a): 40</code><!-- raw HTML omitted -->
<code>test2 a: &amp;[[10 11 12 13 14] [20 21 22 23 24]] len(a): 2 sizeof(a): 4</code><!-- raw HTML omitted --></p>
<p>可以看到，当在函数间传递的数据量很大时，参数为数组导致的开销最大，参数为切片时开销固定为12各字节，当然传递指针开销只占4个字节，指针是最节省空间的。<!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/L6D2RS2ve5V"><strong>🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫  P L A Y A R O U N D 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞 🍫 🍰 🥞</strong></a></p>
<h1 id="4-">4. 映射</h1>
<p>go语言的映射(maps)实现了哈希表(hash)，映射和指针、切片一样，都是引用类型，引用类型声明的变量不能直接赋值，
需要使用map先分配并初始化一个哈希表的数据结构，然后返回一个指向这个数据结构的值
go语言中map类型map样式为：[KeyType]ValueType， KeyType可以是任何<a href="https://golang.org/ref/spec#Comparison_operators">可比较的类型</a>，
ValueType可以是任何类型。</p>
<h2 id="41-">4.1 映射声明与初始化</h2>
<p>map创建的方式一： 先声明变量，再用make分配空间  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span> <span style="color:#75715e">//声明一个类型为map[string]int的变量m
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m header address: %06p, m hash header address %06p.\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)

<span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>) <span style="color:#75715e">//使用make为m分配类型为map[string]int的哈希表
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m header address: %06p, m hash header address %06p.\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)

<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;aaa&#34;</span>] = <span style="color:#ae81ff">111</span>
<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;bbb&#34;</span>] = <span style="color:#ae81ff">222</span>
<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;ccc&#34;</span>] = <span style="color:#ae81ff">333</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)
</code></pre></div><p><code>m header address: 0x40c128, m hash header address 0x000000.</code><!-- raw HTML omitted -->
<code>m header address: 0x40c128, m hash header address 0x43e260.</code><!-- raw HTML omitted -->
<code>m:  map[aaa:111 bbb:222 ccc:333]</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/afhMcDGie9O"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<p>map创建的方式二： 直接用make创建并分配空间  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)

<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;aaa&#34;</span>] = <span style="color:#ae81ff">111</span>
<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;bbb&#34;</span>] = <span style="color:#ae81ff">222</span>
<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;ccc&#34;</span>] = <span style="color:#ae81ff">333</span>

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m header address: %06p, m hash header address %06p.\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)
</code></pre></div><p><code>m header address: 0x40c128, m hash header address 0x43e260.</code><!-- raw HTML omitted -->
<code>m:  map[aaa:111 bbb:222 ccc:333]</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/Yw9MbkgsaCR"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<p>map创建的方式三： 用空映射来初始化m变量，效果等同于方式二  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{}

<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;aaa&#34;</span>] = <span style="color:#ae81ff">111</span>
<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;bbb&#34;</span>] = <span style="color:#ae81ff">222</span>
<span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;ccc&#34;</span>] = <span style="color:#ae81ff">333</span>

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m header address: %06p, m hash header address %06p.\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)
</code></pre></div><p><code>m header address: 0x40c128, m hash header address 0x43e260.</code><!-- raw HTML omitted -->
<code>m:  map[aaa:111 bbb:222 ccc:333]</code></p>
<p><a href="https://play.golang.org/p/aYYAHSajLCn"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<p>map创建的方式四： 用字面量初始化m变量  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;aaa&#34;</span>:<span style="color:#ae81ff">111</span>, <span style="color:#e6db74">&#34;bbb&#34;</span>:<span style="color:#ae81ff">222</span>, <span style="color:#e6db74">&#34;ccc&#34;</span>:<span style="color:#ae81ff">333</span> }

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m header address: %06p, m hash header address %06p.\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)
</code></pre></div><p><code>m header address: 0x40c128, m hash header address 0x43e260.</code><!-- raw HTML omitted -->
<code>m:  map[aaa:111 bbb:222 ccc:333]</code></p>
<p><a href="https://play.golang.org/p/LFfogtZ5Zsa"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<h2 id="42-">4.2 遍历映射</h2>
<p>用range遍历map  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;aaa&#34;</span>: <span style="color:#ae81ff">111</span>, <span style="color:#e6db74">&#34;bbb&#34;</span>: <span style="color:#ae81ff">222</span>, <span style="color:#e6db74">&#34;ccc&#34;</span>: <span style="color:#ae81ff">333</span>}

<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;key&#34;</span>, <span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;value&#34;</span>, <span style="color:#a6e22e">v</span>)
}
</code></pre></div><p><code>key ccc value 333</code><!-- raw HTML omitted -->
<code>key aaa value 111</code><!-- raw HTML omitted -->
<code>key bbb value 222</code><!-- raw HTML omitted --></p>
<p>没错，map存储的键值对是无序的，所以每次从map中取出的键值对顺序与存入的顺序可能是不一样的。</p>
<p><a href="https://play.golang.org/p/KN82CWihtJN"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<h2 id="43-">4.3 有序打印</h2>
<p>有序打印map中的键值对  //adm</p>
<p>上面的例子我们看到map中键值对的输出是无序的，但有时候我们需要有序的输出map中的键值对，这里可以对map中的Key进行排序， 然后再取Value的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">kod</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{}
<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;aaa&#34;</span>: <span style="color:#ae81ff">111</span>, <span style="color:#e6db74">&#34;bbb&#34;</span>: <span style="color:#ae81ff">222</span>, <span style="color:#e6db74">&#34;ccc&#34;</span>: <span style="color:#ae81ff">333</span>}

<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
	<span style="color:#a6e22e">kod</span> = append(<span style="color:#a6e22e">kod</span>, <span style="color:#a6e22e">k</span>)
}

<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Strings</span>(<span style="color:#a6e22e">kod</span>)

<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">kod</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Key&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;Value&#34;</span>, <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">s</span>])
}
</code></pre></div><p><code>Key aaa value 111</code><!-- raw HTML omitted -->
<code>Key bbb value 222</code><!-- raw HTML omitted -->
<code>Key ccc value 333</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/F0HrAVmsNET"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<p>有效的判断map中是否含有你要找的Key  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">exist</span> <span style="color:#66d9ef">bool</span>

<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;aaa&#34;</span>: <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;bbb&#34;</span>: <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;ccc&#34;</span>: <span style="color:#ae81ff">3</span>}

<span style="color:#75715e">//bbb在map中，v为222，exist为true.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">exist</span> = <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;bbb&#34;</span>]
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;bbb value&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">exist</span>)

<span style="color:#75715e">//xyz不在map中，虽然v能打印出值0（实际上是int型变量的默认值），但exist为false，这种为不安全的取值。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">exist</span> = <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;xyz&#34;</span>]
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;xyz value&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">exist</span>)

<span style="color:#75715e">//所以需要先判断exist的布尔值，exist为true说明xyz存在于map中，这时候对应的Value是有效的，否则就是xyz不存在于map中。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">exist</span> = <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;xyz&#34;</span>]; <span style="color:#a6e22e">exist</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;xyz value&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">exist</span>)

} <span style="color:#66d9ef">else</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Key xyz doesn&#39;t exist in map&#34;</span>)
}
</code></pre></div><p><code>bbb value 2 true</code><!-- raw HTML omitted -->
<code>xyz value 0 false</code><!-- raw HTML omitted -->
<code>Key xyz doesn't exist in map</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/HCrPO1n5mlc"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<h2 id="44-">4.4 删除键值</h2>
<p>删除map中的键值对  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;aaa&#34;</span>: <span style="color:#ae81ff">111</span>, <span style="color:#e6db74">&#34;bbb&#34;</span>: <span style="color:#ae81ff">222</span>, <span style="color:#e6db74">&#34;ccc&#34;</span>: <span style="color:#ae81ff">333</span>}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)

delete(<span style="color:#a6e22e">m</span>, <span style="color:#e6db74">&#34;aaa&#34;</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)

delete(<span style="color:#a6e22e">m</span>, <span style="color:#e6db74">&#34;opq&#34;</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;m: &#34;</span>, <span style="color:#a6e22e">m</span>)
</code></pre></div><p><code>m:  map[aaa:111 bbb:222 ccc:333]</code><!-- raw HTML omitted -->
<code>m:  map[bbb:222 ccc:333]</code><!-- raw HTML omitted -->
<code>m:  map[bbb:222 ccc:333]</code></p>
<p>delete函数用于删除map中的键值对，它没有返回值，即使要删除的Key不在map中，delete也可以正常执行。</p>
<p><a href="https://play.golang.org/p/_zbYO7zEAw5"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<h1 id="5-">5. 函数</h1>
<p>go语言中函数的声明格式如下:<!-- raw HTML omitted -->
包含一个函数名name，一个参数列表parameter-list和一个返回结果列表result-list和一个函数体body。</p>
<blockquote>
<p>func name(parameter-list) (result-list) {<!-- raw HTML omitted -->
    body<!-- raw HTML omitted -->
}</p>
</blockquote>
<h2 id="51-">5.1 函数签名</h2>
<p>如果2个函数的参数类型相同，返回值类型也相同，则这2个函数具有相同的类型，函数的类型就是函数的签名。  //adm</p>
<p>如下声明了4个函数，它们均有2个int型参数和一个int型返回值，这4个函数的类型相同，签名也相同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sig1</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sig2</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sig3</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">_</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sig4</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sig1: %T\n&#34;</span>, <span style="color:#a6e22e">sig1</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sig2: %T\n&#34;</span>, <span style="color:#a6e22e">sig2</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sig3: %T\n&#34;</span>, <span style="color:#a6e22e">sig3</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sig4: %T\n&#34;</span>, <span style="color:#a6e22e">sig4</span>)
}
</code></pre></div><p><code>sig1: func(int, int) int</code><!-- raw HTML omitted -->
<code>sig2: func(int, int) int</code><!-- raw HTML omitted -->
<code>sig3: func(int, int) int</code><!-- raw HTML omitted -->
<code>sig4: func(int, int) int</code><!-- raw HTML omitted --></p>
<p>函数声明的参数叫parameter（形参），调用者给函数传递的参数叫argument（实参）。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>如果在go语言中遇到了一个没有函数体的函数声明，只有函数的签名，说明这个函数不是由go语言实现的。  //adm</p>
<p>比如：<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">math</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sin</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> <span style="color:#75715e">// implemented in assembly language.
</span></code></pre></div><h2 id="52-">5.2 递归调用</h2>
<p>递归函数可以自己调用自己，但要设置返回条件，避免递归无限调用。  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">recursion</span>(<span style="color:#a6e22e">slice</span> []<span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">slice</span> = append(<span style="color:#a6e22e">slice</span>, len(<span style="color:#a6e22e">slice</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice</span>)
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">slice</span>) &lt; <span style="color:#ae81ff">20</span> {
		<span style="color:#a6e22e">recursion</span>(<span style="color:#a6e22e">slice</span>)
	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">slice</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">mainslice</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">recursion</span>(<span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;mainslice:&#34;</span>, <span style="color:#a6e22e">mainslice</span>, <span style="color:#e6db74">&#34;len:&#34;</span>, len(<span style="color:#a6e22e">mainslice</span>), <span style="color:#e6db74">&#34;cap:&#34;</span>, cap(<span style="color:#a6e22e">mainslice</span>))
}
</code></pre></div><p><code>[1]</code><!-- raw HTML omitted -->
<code>[1 2]</code><!-- raw HTML omitted -->
<code>[1 2 3]</code><!-- raw HTML omitted -->
<code>[1 2 3 4]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19]</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]</code><!-- raw HTML omitted -->
<code>mainslice: [1] len: 1 cap: 1</code><!-- raw HTML omitted --></p>
<p>以上例子中main函数给recursion函数传递了一个nil slice，之后recursion函数给slice append一个数值（当前slice的长度加1），然后打印出slice的结果，最后在slice length小于20的情况下进行回调。<!-- raw HTML omitted -->
可以看到recursion函数最后返回给main函数的切片mainslice的元素是1，长度len和容量cap也是1，这是第一次对recursion函数调用return回的结果。<!-- raw HTML omitted -->
recursion函数对自己再次调用时，每个recursion函数中的slice参数都相当于调用者slice参数的副本，副本相当于这个函数体内的本地变量，函数中对本地变量的更改并不影响调用者里的slice的大小和内容，如果将slice的地址传递给被调函数，则被调函数对slice的更改会影响调用者里slice的大小和内容。<!-- raw HTML omitted --></p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<h2 id="53-">5.3 函数类型</h2>
<p>函数的签名也是一种类型，比如下面main函数中的函数变量f，f的函数类型和add、sub的签名一致，所以add和sub函数均可赋给函数变量f。  //adm
需要注意的是函数和slice、map一样，均属于不可比较的类型，它们的变量只能与nil比较，这些不可比较的类型变量不能用作map的key。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sub</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#75715e">//fmt.Println(f == f) //invalid operation: f == f (func can only be compared to nil)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">add</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;5 + 3: &#34;</span>, <span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>))
	<span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">sub</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;5 - 3: &#34;</span>, <span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>))
}
</code></pre></div><p><code>true</code><!-- raw HTML omitted -->
<code>5 + 3:  8</code><!-- raw HTML omitted -->
<code>5 - 3:  2</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<!-- raw HTML omitted -->
<p>strings.Map对字符串中的每个字符调用add1 函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">rune</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Map</span>(<span style="color:#a6e22e">add1</span>, <span style="color:#e6db74">&#34;HAL-9000&#34;</span>)) <span style="color:#75715e">// &#34;IBM.:111&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Map</span>(<span style="color:#a6e22e">add1</span>, <span style="color:#e6db74">&#34;VMS&#34;</span>))      <span style="color:#75715e">// &#34;WNT&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Map</span>(<span style="color:#a6e22e">add1</span>, <span style="color:#e6db74">&#34;Admix&#34;</span>))    <span style="color:#75715e">// &#34;Benjy&#34;
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>IBM.:111</code><!-- raw HTML omitted -->
<code>WNT</code><!-- raw HTML omitted -->
<code>Benjy</code><!-- raw HTML omitted --></p>
<p>string.Map的签名如下：<!-- raw HTML omitted -->
func Map(mapping func(rune) rune, s string) string</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>改自gopl 5.5的例子  //adm</p>
<p>fmt.Printf中的%<em>s的</em>表示要打印的空格的个数，空格的数量为i*2个，然后再按%s打印&rdquo;-&rdquo;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%*s\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;-&#34;</span>)
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%*s\n&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;-&#34;</span>)
	}
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">-</span>
 <span style="color:#f92672">-</span>
   <span style="color:#f92672">-</span>
     <span style="color:#f92672">-</span>
       <span style="color:#f92672">-</span>
         <span style="color:#f92672">-</span>
           <span style="color:#f92672">-</span>
             <span style="color:#f92672">-</span>
               <span style="color:#f92672">-</span>
                 <span style="color:#f92672">-</span>
                   <span style="color:#f92672">-</span>
                 <span style="color:#f92672">-</span>
               <span style="color:#f92672">-</span>
             <span style="color:#f92672">-</span>
           <span style="color:#f92672">-</span>
         <span style="color:#f92672">-</span>
       <span style="color:#f92672">-</span>
     <span style="color:#f92672">-</span>
   <span style="color:#f92672">-</span>
 <span style="color:#f92672">-</span>

</code></pre></div><p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<h2 id="54-">5.4 匿名函数</h2>
<p>匿名函数，也叫函数字面量，是一个没有函数名的函数  //adm</p>
<p>可以将<!-- raw HTML omitted --><code>来自gopl 5.5的例子</code><!-- raw HTML omitted -->中的add1改为成匿名函数并传给strings.Map<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Map</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">rune</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }, <span style="color:#e6db74">&#34;HAL-9000&#34;</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Map</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">rune</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }, <span style="color:#e6db74">&#34;VMS&#34;</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Map</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">rune</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }, <span style="color:#e6db74">&#34;Admix&#34;</span>))
}
</code></pre></div><p><code>IBM.:111</code><!-- raw HTML omitted -->
<code>WNT</code><!-- raw HTML omitted -->
<code>Benjy</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>如果匿名函数在另一个函数内，那么匿名函数拥有另一个函数的完整词法环境，匿名函数可以访问另一个函数里的变量  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>() <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">i</span> = <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add</span> <span style="color:#75715e">// s是一个指向add函数的指针
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;add addr:&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">int</span> <span style="color:#75715e">// f是一个func() int函数类型的变量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">/* square()的返回值是函数体内的匿名函数，将匿名函数
</span><span style="color:#75715e">		func() int {
</span><span style="color:#75715e">			i = i + 1
</span><span style="color:#75715e">			return i
</span><span style="color:#75715e">		}
</span><span style="color:#75715e">	赋给f
</span><span style="color:#75715e">	*/</span>
	<span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">s</span>() <span style="color:#75715e">//将add()函数的执行结果返回给f，f现在是匿名函数，它能继续引用add函数体内的变量i
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//如下面对f函数的调用f(), 每调用一次i都加1。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//对于add函数内的变量i来说，这种匿名函数对i的调用一定程度上类似于C语言内的static int i = 1。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;  f addr:&#34;</span>, <span style="color:#a6e22e">f</span>, <span style="color:#e6db74">&#34;f():&#34;</span>, <span style="color:#a6e22e">f</span>()) <span style="color:#75715e">//匿名函数调用结果 2
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;  f addr:&#34;</span>, <span style="color:#a6e22e">f</span>, <span style="color:#e6db74">&#34;f():&#34;</span>, <span style="color:#a6e22e">f</span>()) <span style="color:#75715e">//匿名函数调用结果 3
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;  f addr:&#34;</span>, <span style="color:#a6e22e">f</span>, <span style="color:#e6db74">&#34;f():&#34;</span>, <span style="color:#a6e22e">f</span>()) <span style="color:#75715e">//匿名函数调用结果 4
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;  f addr:&#34;</span>, <span style="color:#a6e22e">f</span>, <span style="color:#e6db74">&#34;f():&#34;</span>, <span style="color:#a6e22e">f</span>()) <span style="color:#75715e">//匿名函数调用结果 5
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>add addr: 0x10914e0</code><!-- raw HTML omitted -->
<code>  f addr: 0x1091990 f(): 2</code><!-- raw HTML omitted -->
<code>  f addr: 0x1091990 f(): 3</code><!-- raw HTML omitted -->
<code>  f addr: 0x1091990 f(): 4</code><!-- raw HTML omitted -->
<code>  f addr: 0x1091990 f(): 5</code><!-- raw HTML omitted --></p>
<p>通过这个例子，我们看到变量的生命周期不由它的作用域决定:add返回后，变量i仍然隐式的存在于f中。
f中存在变量i的引用。这就是函数值属于引用类型和函数值不可比较的原因。
Go使用闭包(closures)技术实现函数值，Go程序员也把函数值叫做闭包。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>匿名函数与for循环连用的例子  //adm</p>
<p>for循环行<code>for _, s := range slice</code>的s是一个循环体内可访问的局部变量，匿名函数在for循环内，所以匿名函数可以引用变量s，<!-- raw HTML omitted -->
考虑下面代码打印都是10的原因<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fs</span> []<span style="color:#66d9ef">func</span>()
	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slice</span> {
		<span style="color:#a6e22e">fs</span> = append(<span style="color:#a6e22e">fs</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>) })
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">fs</span> {
		<span style="color:#a6e22e">f</span>()
	}
}
</code></pre></div><p><code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted -->
<code>0xc00006c008 10</code><!-- raw HTML omitted --></p>
<p>由于s的地址始终都是0xc00006c008，所以最后在调用fs切片的每个函数元素f()时，f()引用的都是同一个s，s存储的是slice切片最后的一个值10。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>通过让匿名函数引用不同的变量s即可解决这个问题，在for循环里加一行 s := s即可在每次for循环时都为为匿名函数新增一个s变量的副本，这个副本在每次for循环时都会具有新的地址，并不影响<code>for _, s := range slice</code>这一行s变量的地址。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fs</span> []<span style="color:#66d9ef">func</span>()
	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slice</span> {
		<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>
		<span style="color:#a6e22e">fs</span> = append(<span style="color:#a6e22e">fs</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>) })
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">fs</span> {
		<span style="color:#a6e22e">f</span>()
	}
}
</code></pre></div><p><code>0xc000016080 1</code><!-- raw HTML omitted -->
<code>0xc000016088 2</code><!-- raw HTML omitted -->
<code>0xc000016090 3</code><!-- raw HTML omitted -->
<code>0xc000016098 4</code><!-- raw HTML omitted -->
<code>0xc0000160a0 5</code><!-- raw HTML omitted -->
<code>0xc0000160a8 6</code><!-- raw HTML omitted -->
<code>0xc0000160b0 7</code><!-- raw HTML omitted -->
<code>0xc0000160b8 8</code><!-- raw HTML omitted -->
<code>0xc0000160c0 9</code><!-- raw HTML omitted -->
<code>0xc0000160c8 10</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<h2 id="55-">5.5 变参函数</h2>
<p>在函数参数列表的最后一个类型前加上&hellip;，表示这个函数可以接收任意个数量的该类型的参数。  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">i</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">s</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;add1: i type: %T, sum: %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">sum</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add2</span>(<span style="color:#a6e22e">i</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">i</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">s</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;add2: i type: %T, sum: %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">sum</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;add1 type:%T\n&#34;</span>, <span style="color:#a6e22e">add1</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;add2 type:%T\n&#34;</span>, <span style="color:#a6e22e">add2</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}
	<span style="color:#a6e22e">add1</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>) <span style="color:#75715e">//1. main函数隐式的把add的参数放到一个切片里，然后再传给add函数。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">add1</span>(<span style="color:#a6e22e">s</span><span style="color:#f92672">...</span>)                      <span style="color:#75715e">//2. main函数向add1变参函数真的传递一个切片的时候，需要在切片变量后面加入...，以告知add1这回真是个切片。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">add2</span>(<span style="color:#a6e22e">s</span>)                         <span style="color:#75715e">//3. main函数向add2(参数为切片)传参的时候，直接写s即可。
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>add1 type:func(...int)</code><!-- raw HTML omitted -->
<code>add2 type:func([]int)</code><!-- raw HTML omitted --></p>
<p><code>add1: i type: []int, sum: 45</code><!-- raw HTML omitted -->
<code>add1: i type: []int, sum: 45</code><!-- raw HTML omitted -->
<code>add2: i type: []int, sum: 45</code><!-- raw HTML omitted --></p>
<p>add1函数的参数为可变参数，add2函数的参数是一个切片，前2行打印的是函数的类型，可以看到<code>func(...int)</code>和<code>func([]int)</code>是2个不同的类型。<!-- raw HTML omitted --><!-- raw HTML omitted -->
接下来的3行打印均相同，均为<code>add1: i type: []int, sum: 45</code>:<!-- raw HTML omitted -->
第1行和第2行的打印是main函数向add1分别传入了一些参数(1到9)和一个切片(内容为1到9)，但在add1中打印参数i的类型时，2次均是[]int，这可以证实我们代码注释里说的&quot;1. main函数隐式的把add的参数放到一个切片里，然后再传给add函数。&ldquo;<!-- raw HTML omitted -->
第3行参数是main函数直接调用了一个参数为切片的add2，并向add2传递了一个切片s，这行的打印和上2行一致，作为对比用。<!-- raw HTML omitted --></p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>一个神奇的类型: interface{}  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">anytype</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">anytype</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
	<span style="color:#a6e22e">anytype</span>(<span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#e6db74">&#34;def&#34;</span>, <span style="color:#e6db74">&#34;ghi&#34;</span>, <span style="color:#e6db74">&#34;jkl&#34;</span>)
	<span style="color:#a6e22e">anytype</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;def&#34;</span>, <span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">3.14</span>)
}
</code></pre></div><p><code>[1 2 3 4]</code><!-- raw HTML omitted -->
<code>[abc def ghi jkl]</code><!-- raw HTML omitted -->
<code>[1 def true 3.14]</code><!-- raw HTML omitted --></p>
<p>interface{}表示能接收任意类型的参数，如果用它做可变参数的类型，那岂不是&hellip; 😄 🤩 🤪</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<h2 id="56-">5.6 延迟调用</h2>
<p>当你在编写一个读写文件的程序，为了保证文件正确读取，可能要判断多次是否已读取到想要的大小或是否已到达EOF，
然后在不同的判断位置加入close文件的操作并返回，go中有个defer关键字，defer 后面跟一个函数名，用于在当前函数执行完时，
再执行defer后面的函数，这样我们只需写一个defer close()就可以保证文件一定会关闭，不用在多个地方加入close()的操作。<!-- raw HTML omitted --></p>
<p>不论包含defer语句的函数是return返回还是panic异常结束，defer后面的函数都会被最后执行, 当然你要保证在return或者panic
之前系统已执行完你的defer语句，通常在申请完资源后就加上defer释放资源的函数，如果你在return后面加defer释放资源的函数，
那这个defer语句在return之后就执行不到了，defer后面的函数也自然执行不到。<!-- raw HTML omitted -->
如果你在函数中加入了多条defer语句，那么这些defer的函数会按相反的声明顺序执行。<!-- raw HTML omitted --></p>
<p>defer适用于打开、关闭文件；连接、断开连接；加锁、解锁；<!-- raw HTML omitted --></p>
<p>摘自gopl 5.8的例子  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ReadFile</span>(<span style="color:#a6e22e">filename</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
    <span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#a6e22e">filename</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
    }
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Close</span>()
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ReadAll</span>(<span style="color:#a6e22e">f</span>)
}
</code></pre></div><p>来自gopl 5.8的例子  //adm</p>
<p>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。下例中的 bigSlowOperation函数，
直接调用trace记录函数的被调情况。bigSlowOperation被调时， trace会返回一个函数值，
该函数值会在bigSlowOperation退出时被调用。
通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，
如例子中的start。<!-- raw HTML omitted --><!-- raw HTML omitted -->
需要注意一点:不要忘记defer语句后的圆括号:<!-- raw HTML omitted -->
defer trace(&ldquo;bigSlowOperation&rdquo;)表示在bigSlowOperation函数结束时调用trace函数然后返回trace里的匿名函数，匿名函数不会被执行；<!-- raw HTML omitted -->
defer trace(&ldquo;bigSlowOperation&rdquo;)()表示要执行trace函数里的匿名函数，会先执行trace函数里匿名函数之前的部分，待bigSlowOperation函数结束时再执行trace函数里的匿名函数；<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bigSlowOperation</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">trace</span>(<span style="color:#e6db74">&#34;bigSlowOperation&#34;</span>)() <span style="color:#75715e">// don&#39;t forget the extra parentheses
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// ...lots of work...
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>) <span style="color:#75715e">// simulate slow operation by sleeping
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">trace</span>(<span style="color:#a6e22e">msg</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">func</span>() {
	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;enter %s&#34;</span>, <span style="color:#a6e22e">msg</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;exit %s (%s)&#34;</span>, <span style="color:#a6e22e">msg</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Since</span>(<span style="color:#a6e22e">start</span>))
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">bigSlowOperation</span>()
}
</code></pre></div><p><code>2019/04/03 14:57:39 enter bigSlowOperation</code><!-- raw HTML omitted -->
<code>2019/04/03 14:57:49 exit bigSlowOperation (10.004776382s)</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>defer用于return的返回值  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">int</span>

	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum: &#34;</span>, <span style="color:#a6e22e">sum</span>) }()

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">i</span> {
		<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">s</span>
	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>)
}
</code></pre></div><p><code>sum:  15</code>
<code>sum:  25</code></p>
<p>add 函数中<code>defer func() { fmt.Println(&quot;sum: &quot;, sum) }()</code>的意义是:<!-- raw HTML omitted -->
在return返回之后，defer延迟调用的匿名函数需要访问外部函数的sum变量，<!-- raw HTML omitted -->
<code>func() { fmt.Println(&quot;sum: &quot;, sum) }</code>是匿名函数的声明，匿名函数最后加的<code>()</code>括号是对匿名函数的调用。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>注意defer用在for循环中的情况  //adm</p>
<p>由于defer后面的语句在函数执行完后才会被调用，像下面的代码如果filenames过多的话，
在// &hellip;process f&hellip;之后并没有执行f.Close()，而是在整个for循环结束之后才调用defer的函数执行f.Close()，
这样会导致系统不断分配文件描述符，直到文件描述符耗尽。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">filename</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filenames</span> {
		<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#a6e22e">filename</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
		}
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Close</span>() <span style="color:#75715e">// NOTE: risky; could run out of file descriptors
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// ...process f...
</span><span style="color:#75715e"></span>	}
}
</code></pre></div><p>一个改进的方法是将for循环体里的内容放到一个函数当中，让for循环调用这个函数，这个函数结束时自然就会调用defer
的延迟函数f.Close()进行文件关闭。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">processfile</span>(<span style="color:#a6e22e">file</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Open</span>(<span style="color:#a6e22e">filename</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Close</span>() <span style="color:#75715e">// NOTE: risky; could run out of file descriptors
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// ...process f...
</span><span style="color:#75715e"></span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">filename</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">filenames</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">processfile</span>(<span style="color:#a6e22e">filename</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
		}
	}
}
</code></pre></div><h2 id="57-">5.7 错误处理</h2>
<p>error是接口类型，error为nil意味着函数运行成功，non-nil表示失败。
对于non-nil的error类型,我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p>
<p>错误处理方式一: 调用函数打印被调函数返回的error类型的变量err  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
<span style="color:#75715e">//or
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v&#34;</span>, <span style="color:#a6e22e">err</span>)
</code></pre></div><p>错误处理方式二: 被调函数返回error类型的字符串  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;Failed to get data&#34;</span>)
<span style="color:#75715e">//or
</span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Failed to get data, status: %s&#34;</span>, <span style="color:#a6e22e">status</span>)
</code></pre></div><p>错误处理方式三: 函数直接打印错误信息，遇到不可恢复错误时使用os.Exit(1)退出；或使用log.Fatalf达到相同效果  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;Site is down: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
<span style="color:#75715e">//or
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Site is down: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
</code></pre></div><p>log包中的函数在打印时都会自带时间前缀信息，也可使用如下方式用自己的标志字符串替换时间信息：<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">SetPrefix</span>(<span style="color:#e6db74">&#34;wait: &#34;</span>)
<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">SetFlags</span>(<span style="color:#ae81ff">0</span>)
</code></pre></div><p>错误处理方式三: 被调函数直接打印错误信息，遇到不可恢复错误时使用os.Exit(1)退出；或使用log.Fatalf达到相同效果  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;Site is down: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
<span style="color:#75715e">//or
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;Site is down: %v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
</code></pre></div><h2 id="58-">5.8 崩溃</h2>
<p>Go程序在运行可能会遇到数组访问越界、空指针引用等，这些运行错误会引起panic异常。
panic异常发生时，当前goroutine会中断执行，然后调用当前goroutine中的defer函数，最后再释放当前goroutine的堆栈。</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">3</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main is end&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f(%d)\n&#34;</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span><span style="color:#f92672">/</span><span style="color:#a6e22e">x</span>) <span style="color:#75715e">// panics if x == 0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
}
</code></pre></div><p><code>f(3)</code><!-- raw HTML omitted -->
<code>f(2)</code><!-- raw HTML omitted -->
<code>f(1)</code><!-- raw HTML omitted -->
<code>panic: runtime error: integer divide by zero</code><!-- raw HTML omitted --></p>
<p><code>goroutine 1 [running]:</code><!-- raw HTML omitted -->
<code>main.f(0x0)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67.go:15 +0xcd</code><!-- raw HTML omitted -->
<code>main.f(0x1)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67.go:16 +0xbe</code><!-- raw HTML omitted -->
<code>main.f(0x2)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67.go:16 +0xbe</code><!-- raw HTML omitted -->
<code>main.f(0x3)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67.go:16 +0xbe</code><!-- raw HTML omitted -->
<code>main.main()</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67.go:9 +0x2a</code><!-- raw HTML omitted -->
<code>exit status 2</code><!-- raw HTML omitted --></p>
<p>上述main函数调用了函数f(3)，然后f(3)每次将参数3减1，传给自己进行回调，当参数x为0时，0/x将会引起panic异常，系统输出堆栈的回溯信息。
&ldquo;main is end&quot;没有打印出来,因为在f(0)时已经发生panic，panic异常中断了当前goroutine的继续运行。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>除数为0引起的panic，并在此之前调用defer函数  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">printStack</span>()
	<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">3</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printStack</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> [<span style="color:#ae81ff">4096</span>]<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Stack</span>(<span style="color:#a6e22e">buf</span>[:], <span style="color:#66d9ef">false</span>)
	<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">n</span>])
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f(%d)\n&#34;</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span><span style="color:#f92672">/</span><span style="color:#a6e22e">x</span>) <span style="color:#75715e">// panics if x == 0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
}
</code></pre></div><p><code>f(3)</code><!-- raw HTML omitted -->
<code>f(2)</code><!-- raw HTML omitted -->
<code>f(1)</code><!-- raw HTML omitted -->
<code>goroutine 1 [running]:</code><!-- raw HTML omitted -->
<code>main.printStack()</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:16 +0x5b</code><!-- raw HTML omitted -->
<code>panic(0x10ab4a0, 0x115f530)</code><!-- raw HTML omitted -->
<code>	/usr/local/go/src/runtime/panic.go:513 +0x1b9</code><!-- raw HTML omitted -->
<code>main.f(0x0)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:21 +0xcd</code><!-- raw HTML omitted -->
<code>main.f(0x1)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:22 +0xbe</code><!-- raw HTML omitted -->
<code>main.f(0x2)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:22 +0xbe</code><!-- raw HTML omitted -->
<code>main.f(0x3)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:22 +0xbe</code><!-- raw HTML omitted -->
<code>main.main()</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:11 +0x46</code><!-- raw HTML omitted -->
<code>panic: runtime error: integer divide by zero</code><!-- raw HTML omitted --></p>
<p><code>goroutine 1 [running]:</code><!-- raw HTML omitted -->
<code>main.f(0x0)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:21 +0xcd</code><!-- raw HTML omitted -->
<code>main.f(0x1)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:22 +0xbe</code><!-- raw HTML omitted -->
<code>main.f(0x2)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:22 +0xbe</code><!-- raw HTML omitted -->
<code>main.f(0x3)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:22 +0xbe</code><!-- raw HTML omitted -->
<code>main.main()</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-1.go:11 +0x46</code><!-- raw HTML omitted -->
<code>exit status 2</code><!-- raw HTML omitted --></p>
<p>printStack函数用于打印运行时goroutine的堆栈信息，从打印顺序可以看出，
defer函数<code>main.printStack()</code><!-- raw HTML omitted -->在<code>panic: runtime error: integer divide by zero</code>前先输出。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<p>直接调用panic函数也会引发异常，但须慎用  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">3</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
		panic(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;stop recursion when x is %d&#34;</span>, <span style="color:#a6e22e">x</span>))
	}

	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
}
</code></pre></div><p><code>panic: stop recursion when x is 1</code><!-- raw HTML omitted --></p>
<p><code>goroutine 1 [running]:</code><!-- raw HTML omitted -->
<code>main.f(0x1)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-2.go:13 +0xee</code><!-- raw HTML omitted -->
<code>main.f(0x2)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-2.go:16 +0x38</code><!-- raw HTML omitted -->
<code>main.f(0x3)</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-2.go:16 +0x38</code><!-- raw HTML omitted -->
<code>main.main()</code><!-- raw HTML omitted -->
<code>	/Users/zhuwenjun/work/golang/post_routine/67-2.go:8 +0x2a</code><!-- raw HTML omitted -->
<code>exit status 2</code><!-- raw HTML omitted --></p>
<p>有些panic异常也可以使用error机制代替。</p>
<p><a href="-"><strong>🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 P L A Y A R O U N D 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗 🌽 🥬  🥗</strong></a></p>
<h2 id="59-">5.9 恢复</h2>
<p>Go语言中panic和recover的函数原型如下。recover函数用于从panic异常中返回，recover函数的返回值就是panic函数的参数。</p>
<blockquote>
<p>func panic(v interface{})<!-- raw HTML omitted -->
func recover() interface{}</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">3</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main is end&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;internal error(x = %d). %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">p</span>)
		}
	}()

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f(%d)\n&#34;</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span><span style="color:#f92672">/</span><span style="color:#a6e22e">x</span>) <span style="color:#75715e">// panics if x == 0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
}
</code></pre></div><p><code>f(3)</code><!-- raw HTML omitted -->
<code>f(2)</code><!-- raw HTML omitted -->
<code>f(1)</code><!-- raw HTML omitted -->
<code>internal error(x = 0). runtime error: integer divide by zero</code><!-- raw HTML omitted -->
<code>main is end</code><!-- raw HTML omitted --></p>
<p>recover函数用于从panic异常中恢复，当f(0)发生异常时，系统先是调用f(0)的defer函数使用recover函数查找错误原因，然后从panic中恢复，可以看到f(0)异常发生时并未中断当前goroutine的继续运行，
<code>main is end</code>仍能继续打印。可以与5.8节中的<!-- raw HTML omitted --><code>除数为0引起的panic</code><!-- raw HTML omitted -->进行对比。</p>
<h1 id="6-">6. 方法</h1>
<p>T是定义的类型(也叫命名类型)，在函数声明的函数名前面加一个类型T，那么这个函数就叫做这个类型的方法，这个类型的变量都能调用（接收）这个方法，T不能为指针或者interface类型:<!-- raw HTML omitted --></p>
<blockquote>
<p>func (t T) name(parameter-list) (result-list) {<!-- raw HTML omitted -->
    body<!-- raw HTML omitted -->
}</p>
</blockquote>
<h2 id="61-">6.1 方法声明</h2>
<p>方法声明的举例如下  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">geometry</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Point</span> <span style="color:#66d9ef">struct</span>{ <span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span> }

<span style="color:#75715e">// traditional function
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#a6e22e">Point</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Hypot</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#75715e">// same thing, but as a method of the Point type
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Point</span>) <span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">q</span> <span style="color:#a6e22e">Point</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Hypot</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Y</span>)
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;geometry&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">geometry</span>.<span style="color:#a6e22e">Point</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">p2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">geometry</span>.<span style="color:#a6e22e">Point</span>{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">100</span>}

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p1</span>.<span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">p2</span>))           <span style="color:#75715e">//方法调用
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">geometry</span>.<span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>)) <span style="color:#75715e">//函数调用
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>95</code><!-- raw HTML omitted -->
<code>95</code><!-- raw HTML omitted --></p>
<p><code>fmt.Println(p1.Distance(p2))</code>是方法调用，<code>fmt.Println(geometry.Distance(p1, p2))</code> 是函数调用。</p>
<p><a href="-"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<p>一次求多个点之间的线段之和  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">geometry</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;math&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Point</span> <span style="color:#66d9ef">struct</span>{ <span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">float64</span> }

<span style="color:#75715e">// traditional function
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#a6e22e">Point</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Hypot</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#75715e">// same thing, but as a method of the Point type
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Point</span>) <span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">q</span> <span style="color:#a6e22e">Point</span>) <span style="color:#66d9ef">float64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Hypot</span>(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">X</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Y</span><span style="color:#f92672">-</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Y</span>)
}

<span style="color:#75715e">// A Path is a journey connecting the points with straight lines.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Path</span> []<span style="color:#a6e22e">Point</span>

<span style="color:#75715e">// Distance returns the distance traveled along the path.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">path</span> <span style="color:#a6e22e">Path</span>) <span style="color:#a6e22e">Distance</span>() <span style="color:#66d9ef">float64</span> {
	<span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">path</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">Distance</span>(<span style="color:#a6e22e">path</span>[<span style="color:#a6e22e">i</span>])
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;geometry&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">geometry</span>.<span style="color:#a6e22e">Path</span>{{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">20</span>}, {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">30</span>}, {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">40</span>}}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Distance</span>())
}
</code></pre></div><p><code>30.14962686336267</code><!-- raw HTML omitted --></p>
<p>虽然Path类型的Distance方法会调用Point类型的Distance方法，但个Distance函数之间没有任何关联。<!-- raw HTML omitted -->
每个类型的方法之间需要有不同的名字，但不同的类型之间的方法名可以相同，就像Path和Point类型的Distance函数名一样，不同类型的方法可以同名。<!-- raw HTML omitted --></p>
<p><a href="-"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<h2 id="62-">6.2 方法接收者为指针</h2>
<p>方法的接收者只有2种类型，T和<em>T，T或</em>T类型的变量均可调用接收者为T和*T的方法  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rbt</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">distance</span>, <span style="color:#a6e22e">step</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rbt</span>) <span style="color:#a6e22e">m</span>(<span style="color:#a6e22e">num</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">distance</span> = <span style="color:#a6e22e">num</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">step</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rbt</span>) <span style="color:#a6e22e">move</span>(<span style="color:#a6e22e">num</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">distance</span> = <span style="color:#a6e22e">num</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">step</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">r1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rbt</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>} <span style="color:#75715e">// r1是rbt类型的普通变量（这里rbt类型的普通变量用于区分*rbt类型的指针变量，如后面的指针变量r2这里叫做指针变量）
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;\nr1.m type: %T r1.move type: %T\n&#34;</span>, <span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">move</span>) <span style="color:#75715e">//r1.m type: func(int) r1.move type: func(int)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;r1 type: %T    &amp;r1 type: %T\n&#34;</span>, <span style="color:#a6e22e">r1</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">r1</span>)            <span style="color:#75715e">//r1 type: main.rbt    &amp;r1 type: *main.rbt
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">m</span>(<span style="color:#ae81ff">7</span>)                  <span style="color:#75715e">//r1是rbt类型的普通变量，方法m的接收者是rbt类型的普通变量，则r1可以直接调用方法m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">distance</span>) <span style="color:#75715e">//0 普通变量r1在调用方法m时，会产生一个r1的副本，这和C语言函数的形参是普通变量，函数调用者给函数传实参后，
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 函数得到的是实参的副本，函数对实参副本的更改并不改变函数调用者的实参值，因此这里普通变量r1的m函数操作的是r1的副本，
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 并不影响真正的实参r1的成员distance的值，所以打印r1.distance时值为0
</span><span style="color:#75715e"></span>
	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">r1</span>).<span style="color:#a6e22e">move</span>(<span style="color:#ae81ff">7</span>)            <span style="color:#75715e">//r1是rbt类型的普通变量，方法move的接收者是*rbt类型的指针变量，取地址符号&amp;可以将r1变成*rbt类型的指针变量：&amp;r1，因此(&amp;r1)可以调用接收者是*rbt类型的方法move
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">distance</span>) <span style="color:#75715e">//35 方法的接收者是指针变量，同C语言将实参传递给指针类型的形参一样，调用者和被调函数共享同一个指针变量，所以被调函数改变形参后，实参也跟着改变，r1.distance为35
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">move</span>(<span style="color:#ae81ff">7</span>)               <span style="color:#75715e">//r1是rbt类型的普通变量，方法move的接收者是*rbt类型的指针变量，r1也可以直接调用方法move，编译器隐式的使用&amp;r1来调用move
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r1</span>.<span style="color:#a6e22e">distance</span>) <span style="color:#75715e">//35 方法接收者是指针变量，方法里对变量的更改会影响指针变量的值，方法里将r1.distance改成了35，再打印r1.distance时也是35
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">r2</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">rbt</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>} <span style="color:#75715e">// r2是*rbt类型的指针变量（这里*rbt类型的指针变量用于区分rbt类型的普通变量，如上面的普通变量r1）
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;\nr2.m type: %T  r2.move type: %T\n&#34;</span>, <span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">move</span>) <span style="color:#75715e">//r2.m type: func(int)  r2.move type: func(int)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;r2 type: %T    *r2 type: %T\n&#34;</span>, <span style="color:#a6e22e">r2</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">r2</span>)             <span style="color:#75715e">//r2 type: *main.rbt    *r2 type: main.rbt
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">m</span>(<span style="color:#ae81ff">7</span>)                  <span style="color:#75715e">//r2是rbt类型的指针变量，方法m的接收者是rbt类型的普通变量，r2也可以直接调用方法m，编译器隐式的使用*r2来调用m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">distance</span>) <span style="color:#75715e">//0 方法接收者是普通变量，方法里更改的是实参的副本，函数对副本的更改并不影响实参的值，r2.distance值仍为0
</span><span style="color:#75715e"></span>
	(<span style="color:#f92672">*</span><span style="color:#a6e22e">r2</span>).<span style="color:#a6e22e">m</span>(<span style="color:#ae81ff">7</span>)               <span style="color:#75715e">//r2是rbt类型的指针变量，方法m的接收者是rbt类型的普通变量，取数据符号*可以将r2变成rbt类型的普通变量:*r2，因此用(*r2)可以调用接收者是rbt类型的方法m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">distance</span>) <span style="color:#75715e">//0 方法接收者是普通变量，方法里更改的是实参的副本，函数对副本的更改并不影响实参的值，r2.distance值仍为0
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">move</span>(<span style="color:#ae81ff">7</span>)               <span style="color:#75715e">//r2是rbt类型的指针变量，方法move的接收者是*rbt类型的指针变量，则r2可以直接调用方法move
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">distance</span>) <span style="color:#75715e">//35 方法接收者是指针变量，方法里对变量的更改会影响指针变量的值，方法里将r1.distance改成了35，再打印r1.distance时也是35
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>r1.m type: func(int) r1.move type: func(int)</code><!-- raw HTML omitted -->
<code>r1 type: main.rbt    &amp;r1 type: *main.rbt</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>35</code><!-- raw HTML omitted -->
<code>35</code><!-- raw HTML omitted --></p>
<p><code>r2.m type: func(int)  r2.move type: func(int)</code><!-- raw HTML omitted -->
<code>r2 type: *main.rbt    *r2 type: main.rbt</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>35</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<p>函数或接口的参数为slice或map的普通变量（非指针变量）时，函数或接口仍能正常修改slice或map中的值  //adm</p>
<p>当我们向被调函数传递一个slice或map类型的指针变量或接收者也为指针时时，在被调函数中对slice或map值的修改能直接改变调用函数中的slice或map值，因为被调函数和调用函数共享同一个slice或map类型指针变量的首地址;<!-- raw HTML omitted -->
当我们向被调函数传递一个slice或map类型的普通变量或接收者也为普通变量时，在被调函数中对slice或map值的修改也能改变调用函数中的slice或map值，虽然被调函数得到的是调用函数中slice或map变量的副本，<!-- raw HTML omitted -->
但这个副本变量里对slice的数组或map的哈希首地址是引用的关系，也就是说副本的地址和调用函数中的变量地址不同，但是副本引用的数组或哈希地址是和调用函数中的相同的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">S</span> []<span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">M</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">func_slice</span>(<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">S</span>) {
	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">555</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nfunc_slice&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;s: %p s: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">s</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给s赋nil值之后，s切片指向底层数组的指针已为nil，但func_slice返回后，仍能打印出s的内容。难道GC机制会判断后面还会用s所以这里s=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;s: %p s: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">func_slice_ptr</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">S</span>) {
	(<span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>)[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">666</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nfunc_slice_ptr&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s: %p *s: %p %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">s</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给s赋nil值之后，s切片指向底层数组的指针已为nil，但func_slice_ptr返回后，仍能打印出s的内容。难道GC机制会判断后面还会用s所以这里s=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s: %p %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
}

<span style="color:#75715e">//[]int是“非定义的类型”，如果method_slice的方法接收者由(s S)改为(s []int)后会导致
</span><span style="color:#75715e"></span><span style="color:#75715e">//&#34;invalid receiver type []int ([]int is not a defined type)&#34;的错误.
</span><span style="color:#75715e"></span><span style="color:#75715e">//type S []int用type定义的S是[]int的定义类型。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">S</span>) <span style="color:#a6e22e">method_slice</span>() {
	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">888</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nmethod_slice&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;s: %p s: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">s</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给s赋nil值之后，s切片指向底层数组的指针已为nil，但method_slice返回后，仍能打印出s的内容。难道GC机制会判断后面还会用s所以这里s=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;s: %p s: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">S</span>) <span style="color:#a6e22e">method_slice_ptr</span>() {
	(<span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>)[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">999</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nmethod_slice_ptr&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s: %p *s: %p %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">s</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给s赋nil值之后，s切片指向底层数组的指针已为nil，但method_slice_ptr返回后，仍能打印出s的内容。难道GC机制会判断后面还会用s所以这里s=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s: %p %#v\n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)
}

<span style="color:#75715e">//##############################################################################################################################
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">func_map</span>(<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">M</span>) {
	<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#e6db74">&#34;ooo&#34;</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nfunc_map&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;m: %p m: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给m赋nil值之后，m切片指向底层数组的指针已为nil，但func_map返回后，仍能打印出m的内容。难道GC机制会判断后面还会用m所以这里m=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;m: %p m: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">func_map_ptr</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">M</span>) {
	(<span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>)[<span style="color:#ae81ff">3</span>] = <span style="color:#e6db74">&#34;ppp&#34;</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nfunc_map_ptr&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m: %p *m: %p %#v\n&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给m赋nil值之后，m切片指向底层数组的指针已为nil，但func_map_ptr返回后，仍能打印出m的内容。难道GC机制会判断后面还会用m所以这里m=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m: %p %#v\n&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
}

<span style="color:#75715e">//map[int]string是“非定义的类型”，如果method_map的方法接收者由(m M)改为(m map[int]string)后会导致
</span><span style="color:#75715e"></span><span style="color:#75715e">//&#34;invalid receiver type map[int]string (map[int]string is not a defined type)&#34;的错误.
</span><span style="color:#75715e"></span><span style="color:#75715e">//type M map[int]string用type定义的S是[]int的定义类型。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">M</span>) <span style="color:#a6e22e">method_map</span>() {
	<span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#e6db74">&#34;xxx&#34;</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nfunc_map&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;m: %p m: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给m赋nil值之后，m切片指向底层数组的指针已为nil，但method_map返回后，仍能打印出m的内容。难道GC机制会判断后面还会用m所以这里m=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;m: %p m: %p %#v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">M</span>) <span style="color:#a6e22e">method_map_ptr</span>() {
	(<span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>)[<span style="color:#ae81ff">3</span>] = <span style="color:#e6db74">&#34;yyy&#34;</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nfunc_map_ptr&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m: %p *m: %p %#v\n&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//TODO: 不确定这里给m赋nil值之后，m切片指向底层数组的指针已为nil，但method_map_ptr返回后，仍能打印出m的内容。难道GC机制会判断后面还会用m所以这里m=nil的赋值没生效？
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m: %p %#v\n&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">S</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">M</span>{<span style="color:#ae81ff">0</span>: <span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#ae81ff">1</span>: <span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#ae81ff">2</span>: <span style="color:#e6db74">&#34;c&#34;</span>, <span style="color:#ae81ff">3</span>: <span style="color:#e6db74">&#34;d&#34;</span>, <span style="color:#ae81ff">4</span>: <span style="color:#e6db74">&#34;e&#34;</span>, <span style="color:#ae81ff">5</span>: <span style="color:#e6db74">&#34;f&#34;</span>}

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s:&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;s: %p s: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">func_slice</span>(<span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;func_slice s:&#34;</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">func_slice_ptr</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;func_slice_ptr s:&#34;</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">method_slice</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;method_slice s:&#34;</span>, <span style="color:#a6e22e">s</span>)

	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>).<span style="color:#a6e22e">method_slice_ptr</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;method_slice_ptr s:&#34;</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\n\nm:&#34;</span>, <span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;&amp;m: %p m: %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>)

	<span style="color:#a6e22e">func_map</span>(<span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;func_map m:&#34;</span>, <span style="color:#a6e22e">m</span>)

	<span style="color:#a6e22e">func_map_ptr</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;func_map_ptr m:&#34;</span>, <span style="color:#a6e22e">m</span>)

	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">method_map</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;method_map m:&#34;</span>, <span style="color:#a6e22e">m</span>)

	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>).<span style="color:#a6e22e">method_map_ptr</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;method_map_ptr m:&#34;</span>, <span style="color:#a6e22e">m</span>)
}
</code></pre></div><p><code>s: [0 1 2 3 4 5]</code><!-- raw HTML omitted -->
<code>&amp;s: 0x40a0e0 s: 0x450000</code><!-- raw HTML omitted --></p>
<p><code>func_slice</code><!-- raw HTML omitted -->
<code>&amp;s: 0x40a110 s: 0x450000 main.S{0, 1, 2, 555, 4, 5}</code><!-- raw HTML omitted -->
<code>&amp;s: 0x40a110 s: 0x0 main.S(nil)</code><!-- raw HTML omitted -->
<code>func_slice s: [0 1 2 555 4 5]</code><!-- raw HTML omitted --></p>
<p><code>func_slice_ptr</code><!-- raw HTML omitted -->
<code>s: 0x40a0e0 *s: 0x450000 &amp;main.S{0, 1, 2, 666, 4, 5}</code><!-- raw HTML omitted -->
<code>s: 0x0 (*main.S)(nil)</code><!-- raw HTML omitted -->
<code>func_slice_ptr s: [0 1 2 666 4 5]</code><!-- raw HTML omitted --></p>
<p><code>method_slice</code><!-- raw HTML omitted -->
<code>&amp;s: 0x40a180 s: 0x450000 main.S{0, 1, 2, 888, 4, 5}</code><!-- raw HTML omitted -->
<code>&amp;s: 0x40a180 s: 0x0 main.S(nil)</code><!-- raw HTML omitted -->
<code>method_slice s: [0 1 2 888 4 5]</code><!-- raw HTML omitted --></p>
<p><code>method_slice_ptr</code><!-- raw HTML omitted -->
<code>s: 0x40a0e0 *s: 0x450000 &amp;main.S{0, 1, 2, 999, 4, 5}</code><!-- raw HTML omitted -->
<code>s: 0x0 (*main.S)(nil)</code><!-- raw HTML omitted -->
<code>method_slice_ptr s: [0 1 2 999 4 5]</code><!-- raw HTML omitted --></p>
<p><code>m: map[0:a 1:b 2:c 3:d 4:e 5:f]</code><!-- raw HTML omitted -->
<code>&amp;m: 0x40c128 m: 0x43e260</code><!-- raw HTML omitted --></p>
<p><code>func_map</code><!-- raw HTML omitted -->
<code>&amp;m: 0x40c168 m: 0x43e260 main.M{0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, 3:&quot;ooo&quot;, 4:&quot;e&quot;, 5:&quot;f&quot;}</code><!-- raw HTML omitted -->
<code>&amp;m: 0x40c168 m: 0x0 main.M(nil)</code><!-- raw HTML omitted -->
<code>func_map m: map[0:a 1:b 2:c 3:ooo 4:e 5:f]</code><!-- raw HTML omitted --></p>
<p><code>func_map_ptr</code><!-- raw HTML omitted -->
<code>m: 0x40c128 *m: 0x43e260 &amp;main.M{0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, 3:&quot;ppp&quot;, 4:&quot;e&quot;, 5:&quot;f&quot;}</code><!-- raw HTML omitted -->
<code>m: 0x0 (*main.M)(nil)</code><!-- raw HTML omitted -->
<code>func_map_ptr m: map[0:a 1:b 2:c 3:ppp 4:e 5:f]</code><!-- raw HTML omitted --></p>
<p><code>func_map</code><!-- raw HTML omitted -->
<code>&amp;m: 0x40c230 m: 0x43e260 main.M{0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, 3:&quot;xxx&quot;, 4:&quot;e&quot;, 5:&quot;f&quot;}</code><!-- raw HTML omitted -->
<code>&amp;m: 0x40c230 m: 0x0 main.M(nil)</code><!-- raw HTML omitted -->
<code>method_map m: map[0:a 1:b 2:c 3:xxx 4:e 5:f]</code><!-- raw HTML omitted --></p>
<p><code>func_map_ptr</code><!-- raw HTML omitted -->
<code>m: 0x40c128 *m: 0x43e260 &amp;main.M{0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, 3:&quot;yyy&quot;, 4:&quot;e&quot;, 5:&quot;f&quot;}</code><!-- raw HTML omitted -->
<code>m: 0x0 (*main.M)(nil)</code><!-- raw HTML omitted -->
<code>method_map_ptr m: map[0:a 1:b 2:c 3:yyy 4:e 5:f]</code><!-- raw HTML omitted --></p>
<p>上面的例子展示了slice和map的函数和方法对参数和接收者为普通变量和指针变量时的修改方法。<!-- raw HTML omitted -->
加这么多打印主要用来对比修改前后的内容和一个疑惑🤔：在被调函数中对slice或map赋值为nil时，<!-- raw HTML omitted -->
被调函数内打印的slice值为(*main.S)(nil)或main.S(nil)，被调函数内打印的map值为main.M(nil)或(*main.M)(nil)，<!-- raw HTML omitted -->
但是从被调函数返回到main函数时，slice或map仍有被赋为nil之前的值，比如main函数里打印的<!-- raw HTML omitted -->
<code>func_slice s: [0 1 2 555 4 5]</code>或<code>func_map m: map[0:a 1:b 2:c 3:ooo 4:e 5:f]</code>，<!-- raw HTML omitted -->
这里有可能是golang的GC将s = ni或m = nil的操作给消除了，待解。</p>
<p><a href="https://play.golang.org/p/BET_ATfoimb"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<p>当一个引用类型(slice, map, channel)的变量被赋为nil后，这个变量仍拥有这个类型所持有的方法，但要注意接收者为nil时对方法的调用  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">M</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">M</span>) <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">idx</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">idx</span>]
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">M</span>) <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">idx</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">idx</span>] = <span style="color:#a6e22e">v</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">M</span>{<span style="color:#ae81ff">0</span>: <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">2</span>: <span style="color:#ae81ff">999</span>, <span style="color:#ae81ff">3</span>: <span style="color:#ae81ff">9999</span>}

	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">get</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>) <span style="color:#75715e">//map[0:9 1:99 2:999 3:9999]
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">set</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">100</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>) <span style="color:#75715e">//map[1:100 2:999 3:9999 0:9]
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">nil</span>

	<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">get</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;ret: &#34;</span>, <span style="color:#a6e22e">ret</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>) <span style="color:#75715e">//map[]
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//m.set(2, 200) //panic: assignment to entry in nil map
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//fmt.Println(m)
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>map[0:9 1:99 2:999 3:9999]'&lt;br&gt;</code>map[0:9 1:100 2:999 3:9999]&lsquo;<!-- raw HTML omitted -->
<code>ret:  0'&lt;br&gt;</code>map[]&lsquo;<!-- raw HTML omitted --></p>
<p><code>m = nil</code>之后，m.get(2)仍能成功调用，因为get方法只是对m的读取，当key(2)在map(m)中不存在时，map(m)将返回0值，，即get(2)返回int型的0.<!-- raw HTML omitted -->
set(2, 200)尝试向一个nil map写值，这时map还没有为哈希表分配地址，所以这时候向map写值将会导致panic。</p>
<p><a href="https://play.golang.org/p/D2g8d_1sglc"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<h2 id="63-">6.3 结构体引用成员类型的方法</h2>
<p>如果一个类型被一个结构体类型包含，则结构体可以直接引用这个类型的成员，结构体也可以直接引用这个类型所拥有的方法  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Arm</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">lefthand</span>, <span style="color:#a6e22e">righthand</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Leg</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">leftleg</span>, <span style="color:#a6e22e">rightleg</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Wing</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">leftwing</span>, <span style="color:#a6e22e">rightwing</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Arm</span>) <span style="color:#a6e22e">move</span>(<span style="color:#a6e22e">angle</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">lefthand</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">angle</span>
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">righthand</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">angle</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Leg</span>) <span style="color:#a6e22e">walk</span>(<span style="color:#a6e22e">step</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">leftleg</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">rightleg</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Wing</span>) <span style="color:#a6e22e">fly</span>(<span style="color:#a6e22e">step</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">leftwing</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">rightwing</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Body</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Arm</span>
	<span style="color:#a6e22e">Leg</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">Wing</span>
	<span style="color:#a6e22e">height</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Body</span>{<span style="color:#a6e22e">Arm</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>}, <span style="color:#a6e22e">Leg</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>}, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Wing</span>{<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>}, <span style="color:#ae81ff">180</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">move</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">walk</span>(<span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>).<span style="color:#a6e22e">fly</span>(<span style="color:#ae81ff">100</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;b.leftwing = %d, b.rightwing = %d\n&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">leftwing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">rightwing</span>)
}
</code></pre></div><p><code>{1 1} {2 2} {50 50} 180</code><!-- raw HTML omitted -->
<code>{3 3} {7 7} {50 50} 180</code><!-- raw HTML omitted -->
<code>{3 3} {7 7} {150 150} 180</code><!-- raw HTML omitted -->
<code>b.leftwing = 150, b.rightwing = 150</code><!-- raw HTML omitted --></p>
<p>类型Arm，Leg，*Wing均有自己的方法，分别为move，walk，fly。<!-- raw HTML omitted --></p>
<ol>
<li>Body包含了Arm，Leg和<em>Wing的类型，Body类型的变量b可以直接引用Arm，Leg和</em>Wing类型的成员，比如最后一行的打印b.leftwing,而不必写成b.<em>Wing.leftwing,<!-- raw HTML omitted -->
b.leftwing这种写法在编译时编译器会生成而外的代码来展开并调用到</em>Wing类型的leftwing变量。<!-- raw HTML omitted --></li>
<li>Body类型的变量b同样能引用Arm, Leg和*Wing所拥有的方法，比如b.move, b.walk, (&amp;b).fly，这些都是Body成员类型的方法。<!-- raw HTML omitted -->
当然了，这些成员类型的方法不能重名，否则b调用时会出现歧义。</li>
</ol>
<p><a href="https://play.golang.org/p/D2g8d_1sglc"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<h2 id="64-">6.4 方法指针</h2>
<p>方法的指针分为2种，变量方法的指针和类型方法的指针  //adm</p>
<p>变量方法的指针，给指针传的参数和给方法传的参数一样；<!-- raw HTML omitted -->
类型方法的指针，给指针传的第一个参数是方法的接收类型的变量，后面再传给指针的参数才是指针指向的方法的参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Arm</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">lefthand</span>, <span style="color:#a6e22e">righthand</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Leg</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">leftleg</span>, <span style="color:#a6e22e">rightleg</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Wing</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">leftwing</span>, <span style="color:#a6e22e">rightwing</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Arm</span>) <span style="color:#a6e22e">move</span>(<span style="color:#a6e22e">angle</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">lefthand</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">angle</span>
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">righthand</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">angle</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Leg</span>) <span style="color:#a6e22e">walk</span>(<span style="color:#a6e22e">step</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">leftleg</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">rightleg</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Wing</span>) <span style="color:#a6e22e">fly</span>(<span style="color:#a6e22e">step</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">leftwing</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">rightwing</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">step</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Body</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Arm</span>
	<span style="color:#a6e22e">Leg</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">Wing</span>
	<span style="color:#a6e22e">height</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Arm</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>}
	<span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Leg</span>{<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>}
	<span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Wing</span>{<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>}

	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Body</span>{<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">l</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">w</span>, <span style="color:#ae81ff">180</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Ori&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	<span style="color:#75715e">//b.move(2)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">bmv</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">move</span> <span style="color:#75715e">//将变量b的方法move(实际上是arm的方法，只是被b引用而已)的地址赋给bmv，bmv其实是b.move的方法指针。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bmv</span>(<span style="color:#ae81ff">2</span>)        <span style="color:#75715e">//向bmv传入参数2，实际上等同于b.move(2)的表示方式。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Arm&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	<span style="color:#75715e">//b.walk(5)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">wk1</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">Leg</span>).<span style="color:#a6e22e">walk</span> <span style="color:#75715e">//将*Leg类型的方法walk赋给wk1， wk1是(*Leg).walk的*Leg类型walk方法的指针
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wk1</span>(<span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>), <span style="color:#ae81ff">5</span>)   <span style="color:#75715e">//(*Leg) 类型的方法walk实际上只有一个参数，但这里却给wk1传递了2个参数，因为wk1的第一个参数需要是wk1这个指针指向的方法的接收者类型的变量，即walk方法的接收者*Leg类型的变量&amp;(b.Leg)，后面的5才是传给walk的参数step.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;\nwk1 type %T\n&#34;</span>, <span style="color:#a6e22e">wk1</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Leg&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	<span style="color:#a6e22e">wk2</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">Body</span>).<span style="color:#a6e22e">walk</span> <span style="color:#75715e">//wk2和wk1都指向walk方法，只不过wk1的walk方法接收者变量是*Leg，wk2的接收者变量类型是*Body
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wk2</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>, <span style="color:#ae81ff">8</span>)          <span style="color:#75715e">//wk2的第一个参数是*Body类型的变量&amp;b，第二个参数8是传给walk的参数step.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;\nwk2 type %T\n&#34;</span>, <span style="color:#a6e22e">wk2</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Leg&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>).<span style="color:#a6e22e">fly</span>(<span style="color:#ae81ff">100</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nWing&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Arm</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Leg</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Wing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">height</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;b.leftwing = %d, b.rightwing = %d\n&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">leftwing</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">rightwing</span>)
}
</code></pre></div><p><code>Ori {1 1} {2 2} {50 50} 180</code><!-- raw HTML omitted -->
<code>Arm {3 3} {2 2} {50 50} 180</code><!-- raw HTML omitted --></p>
<p><code>wk1 type func(*main.Leg, int)</code><!-- raw HTML omitted -->
<code>Leg {3 3} {7 7} {50 50} 180</code><!-- raw HTML omitted --></p>
<p><code>wk2 type func(*main.Body, int)</code><!-- raw HTML omitted -->
<code>Leg {3 3} {15 15} {50 50} 180</code><!-- raw HTML omitted --></p>
<p><code>Wing {3 3} {15 15} {150 150} 180</code><!-- raw HTML omitted -->
<code>b.leftwing = 150, b.rightwing = 150</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/D2g8d_1sglc"><strong>🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯  P L A Y A R O U N D 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰 🍯 🥩 🌰</strong></a></p>
<h1 id="7-">7. 接口</h1>
<h2 id="71-">7.1 接口类型</h2>
<p>接口是一种定义了一组方法的类型，接口类型只定义这组方法，方法由另一种类型来实现，最终接口类型的变量可以指向实现这组方法的类型的变量。接口类型写作:interface  //adm</p>
<p>未定义的接口类型，这个接口类型定义了一个方法<code>eat() error</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">interface</span> {
   <span style="color:#a6e22e">eat</span>() <span style="color:#66d9ef">error</span>
}
</code></pre></div><p>定义的接口类型eater，这个接口类型定义了一个方法<code>eat() error</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eater</span> <span style="color:#66d9ef">interface</span> {
   <span style="color:#a6e22e">eat</span>() <span style="color:#66d9ef">error</span>
}
</code></pre></div><p>未定义的接口类型的别名eater, 这个接口类型定义了一个方法<code>eat() error</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eatalias</span> = <span style="color:#66d9ef">interface</span> {
 	<span style="color:#a6e22e">eat</span>() <span style="color:#66d9ef">error</span>
}
</code></pre></div><p>Go语言中接口(interface)结构体类型的内部定义如下：  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_interface</span> <span style="color:#66d9ef">struct</span> {
   <span style="color:#a6e22e">dynamicTypeInfo</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">struct</span> {
       <span style="color:#a6e22e">dynamicType</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>       <span style="color:#75715e">// the dynamic type
</span><span style="color:#75715e"></span>       <span style="color:#a6e22e">methods</span>     []<span style="color:#f92672">*</span><span style="color:#a6e22e">_function</span> <span style="color:#75715e">// method table
</span><span style="color:#75715e"></span>   }
   <span style="color:#a6e22e">dynamicValue</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// the dynamic value
</span><span style="color:#75715e"></span>}
</code></pre></div><p>接口类型的结构体成员包含一个dynamicTypeInfo结构体指针变量和一个dynamicValue的unsafe.Pointer指针变量.<!-- raw HTML omitted -->
dynamicTypeInfo的2个成员：<!-- raw HTML omitted -->
  dynamicType指向的是实现interface接口方法的类型。<!-- raw HTML omitted -->
  methods切片指向的是实现interface接口方法的类型方法。<!-- raw HTML omitted -->
dynamicValue变量指向的是实现interface接口方法类型的变量。<!-- raw HTML omitted --></p>
<p>接口类型的使用示例如下  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">//eater是定义的接口类型，这个接口类型定义了一个方法eat()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eater</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">eat</span>(<span style="color:#a6e22e">sth</span> <span style="color:#66d9ef">string</span>)
}

<span style="color:#75715e">//kid是定义的结构体类型，这个结构体类型定义了一个string类型的变量name
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">kid</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#75715e">//kid类型实现了eat方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">k</span> <span style="color:#a6e22e">kid</span>) <span style="color:#a6e22e">eat</span>(<span style="color:#a6e22e">sth</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>.<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#34;is eating&#34;</span>, <span style="color:#a6e22e">sth</span>)
}

<span style="color:#75715e">//feed函数有2个参数:
</span><span style="color:#75715e"></span><span style="color:#75715e">//第1个参数是eater接口类型的变量sbd。因为kid类型实现了eater接口要求的eat()方法，
</span><span style="color:#75715e"></span><span style="color:#75715e">//所以kid类型满足eater接口类型的要求, eater接口类型的变量sbd能指向kid类型的变量。
</span><span style="color:#75715e"></span><span style="color:#75715e">//第2个参数是string类型的变量sth，代表要吃的东西。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">feed</span>(<span style="color:#a6e22e">sbd</span> <span style="color:#a6e22e">eater</span>, <span style="color:#a6e22e">sth</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">sbd</span>.<span style="color:#a6e22e">eat</span>(<span style="color:#a6e22e">sth</span>)
	<span style="color:#75715e">//fmt.Printf(&#34;sbd type: %T  value: %s\n&#34;, sbd, sbd) //sbd type: main.kid  value: {Louis}
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kid</span>{<span style="color:#e6db74">&#34;Louis&#34;</span>}

	<span style="color:#a6e22e">feed</span>(<span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;bread&#34;</span>)
	<span style="color:#a6e22e">feed</span>(<span style="color:#a6e22e">k</span>, <span style="color:#e6db74">&#34;apple&#34;</span>)
}
</code></pre></div><p><code>Louis is eating bread</code><!-- raw HTML omitted -->
<code>Louis is eating apple</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/HD7BoI2rUye"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h2 id="72-">7.2 空接口类型</h2>
<p>如果一个接口类型没有定义任何方法，那么它就是空接口类型(blank interface type)。空接口类型写作interface{}  //adm</p>
<p>Go语言中空接口(blank interface)结构体类型的内部定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_interface</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">dynamicType</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>         <span style="color:#75715e">// the dynamic type
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dynamicValue</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// the dynamic value
</span><span style="color:#75715e"></span>}
</code></pre></div><p>相比接口类型，空接口类型不定义任何方法，所以空接口的结构体类型成员不包含接口成员的函数指针切片<code>methods     []*_function // method table</code>。</p>
<p>因为空接口类型interface{}没有定义方法，不论一个类型有没有自身的方法，空接口类型的2个成员dynamicType和dynamicValue都可以指向任何类型和这个类型的变量。
所以空接口类型interface{}在GO语言中是一种万能类型的存在，interface{}类型的变量可以指向任何类型的变量。</p>
<p>空接口类型的使用示例如下  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;bytes&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}<span style="color:#75715e">//空接口类型变量i
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">1</span>	<span style="color:#75715e">//i的dynamicType指向int类型，dynamicValue指向int类型值1
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">1.0</span> <span style="color:#75715e">//i的dynamicType指向float类型，dynamicValue指向float类型值1.0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = <span style="color:#e6db74">&#34;abcdef&#34;</span> <span style="color:#75715e">//i的dynamicType指向string类型，dynamicValue指向string类型值&#34;abcdef&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">string</span>{<span style="color:#ae81ff">0</span>: <span style="color:#e6db74">&#34;monday&#34;</span>} <span style="color:#75715e">//i的dynamicType指向map[int]string类型，dynamicValue指向map[int]string类型值0: &#34;monday&#34;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>} <span style="color:#75715e">//i的dynamicType指向[]int类型，dynamicValue指向[]int类型值1, 2, 3, 4, 5
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#75715e">//i的dynamicType指向bytes.Buffer类型的指针，dynamicValue指向bytes.Buffer类型变量的default值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">i</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">//interface和interface{}类型的0值是nil
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;i type: %-14T &#34;</span>, <span style="color:#a6e22e">i</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; value:&#34;</span>, <span style="color:#a6e22e">i</span>)
}
</code></pre></div><p><code>i type: int             value: 1</code><!-- raw HTML omitted -->
<code>i type: float64         value: 1</code><!-- raw HTML omitted -->
<code>i type: string          value: abcdef</code><!-- raw HTML omitted -->
<code>i type: map[int]string  value: map[0:monday]</code><!-- raw HTML omitted -->
<code>i type: []int           value: [1 2 3 4 5]</code><!-- raw HTML omitted -->
<code>i type: *bytes.Buffer   value:</code><!-- raw HTML omitted -->
<code>i type: &lt;nil&gt;           value: &lt;nil&gt;</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/ETmmBwnF_HW"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h2 id="73-">7.3 给接口变量赋值</h2>
<p>当把另一种类型的变量赋给接口类型的变量时，需要遵循一种规则：另一种类型的方法定义一定要包含接口类型的方法定义。比如接口类型定义了3个方法，<!-- raw HTML omitted -->
要把另一种类型的变量赋给接口类型的变量时，另一种类型的方法定义可以有10个，但这10个方法一定要包含要被赋值的接口类型的方法定义，<!-- raw HTML omitted -->
即赋值类型变量的方法与被赋值接口类型的变量的方法是大于等于的关系。<!-- raw HTML omitted -->
上面的“另一种类型”也包括接口类型，下面的例子解释来上面的描述<!-- raw HTML omitted --></p>
<p>给接口变量赋值的例子  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">human</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">man</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">superman</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can fly&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">h</span> <span style="color:#a6e22e">human</span>      <span style="color:#75715e">//h代表人类
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#75715e">//s代表超人类
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">h</span> = <span style="color:#a6e22e">s</span> <span style="color:#75715e">//s超人类具有人类h所拥有的所有技能: swim，walk，talk，所以可以把s赋给h。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//s = h //人类h会的方法没有超人类s多，人类自身没有fly的技能，所以不能把h赋给s。此行编译会出现如下错误：
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//cannot use h (type human) as type superhuman in assignment: human does not implement superhuman (missing fly method)
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">man</span> <span style="color:#75715e">//m代表一个人
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span> = <span style="color:#a6e22e">m</span>     <span style="color:#75715e">//m这个人实现了h人类的所有技能: swim，walk，talk，所以可以把m赋给h。 h这个接口类型的变量指向了一个实现其3个方法的变量m。
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sm</span> <span style="color:#a6e22e">superman</span> <span style="color:#75715e">//sm代表一个超人
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">sm</span>          <span style="color:#75715e">//sm这个超人实现了s超人类的所有技能: fly，swim，walk，talk，所以可以把sm赋给s。 s这个接口类型的变量指向一个实现了s 4个方法的变量sm.
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//试试h人类指向的这个人m所具有的技能：
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">swim</span>()
	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">walk</span>()
	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">talk</span>()

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>() <span style="color:#75715e">//打印一个空行
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//试试s超人类指向的这个超人sm所具有的技能：
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">fly</span>()
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">swim</span>()
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">walk</span>()
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">talk</span>()

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>() <span style="color:#75715e">//打印一个空行
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">h</span> = <span style="color:#a6e22e">s</span> <span style="color:#75715e">//s超人类具有人类h所拥有的所有技能: swim，walk，talk，所以可以把s赋给h。这时候h指向的是超人sm。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">swim</span>()
	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">walk</span>()
	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">talk</span>()
}
</code></pre></div><p><code>Man can swim</code><!-- raw HTML omitted -->
<code>Man can walk</code><!-- raw HTML omitted -->
<code>Man can talk</code><!-- raw HTML omitted --></p>
<p><code>superman can fly</code><!-- raw HTML omitted -->
<code>superman can swim</code><!-- raw HTML omitted -->
<code>superman can walk</code><!-- raw HTML omitted -->
<code>superman can talk</code><!-- raw HTML omitted --></p>
<p><code>superman can swim</code><!-- raw HTML omitted -->
<code>superman can walk</code><!-- raw HTML omitted -->
<code>superman can talk</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/D2g8d_1sglc"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h2 id="74-">7.4 类型断言</h2>
<p>类型断言(type assertion)就是对接口类型的变量进行类型转换，并检查转换结果的意思，这种转换结果的检查发生在程序运行时。<!-- raw HTML omitted -->
比如要检查某接口类型的变量i要转换成类型T，写作i.(T)。<!-- raw HTML omitted -->
T的类型分为2种：一种是非接口类型，一种是接口类型:<!-- raw HTML omitted -->
如果T是非接口类型：i内部的动态类型(dynamicType)要和T相同，    则i.(T)类型断言（转换结果）成功。<!-- raw HTML omitted -->
如果T是    接口类型：i内部的动态类型(dynamicType)实现了T的方法，则i.(T)类型断言（转换结果）成功。<!-- raw HTML omitted --></p>
<p>类型断言的例子  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">human</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">man</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">superman</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can fly&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">h</span> <span style="color:#a6e22e">human</span>      <span style="color:#75715e">//h代表人类
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#75715e">//s代表超人类
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">man</span> <span style="color:#75715e">//m代表一个人
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span> = <span style="color:#a6e22e">m</span>     <span style="color:#75715e">//m这个人实现了h人类的所有技能: swim，walk，talk，所以可以把m赋给h。 h这个接口类型的变量指向了一个实现其3个方法的变量m, m的方法和m的类型man。
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sm</span> <span style="color:#a6e22e">superman</span> <span style="color:#75715e">//sm代表一个超人
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">sm</span>          <span style="color:#75715e">//sm这个超人实现了s超人类的所有技能: fly，swim，walk，talk，所以可以把sm赋给s。 s这个接口类型的变量指向一个实现了s 4个方法的变量sm，sm的方法和sm的类型superman。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>() <span style="color:#75715e">//打印一个空行
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i.(T) type asertion (type conversion check) test&#34;</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nT is a non-interface type:&#34;</span>) <span style="color:#75715e">//T是非接口类型的情况, i指向的动态类型一定要和T非接口的类型相同，则断言成功。因为h的动态类型是man，所以h.(superman)是断言失败的。s的动态类型是superman，所以s.(man)也是断言失败的。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;h.(man)          type asertion (type conversion check) is %T\n&#34;</span>, <span style="color:#a6e22e">h</span>.(<span style="color:#a6e22e">man</span>))
	<span style="color:#75715e">//fmt.Printf(&#34;h.(superman)   type asertion (type conversion check) is %T\n&#34;, h.(superman)) //panic: interface conversion: main.human is main.man, not main.superman
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s.(superman)     type assertion (type conversion check) is %T\n&#34;</span>, <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">superman</span>))
	<span style="color:#75715e">//fmt.Printf(&#34;s.(man)        type assertion (type conversion check) is %T\n&#34;, s.(man)) //impossible type assertion: man does not implement superhuman (missing fly method)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nT is a interface type:&#34;</span>) <span style="color:#75715e">//T是接口类型的情况， i指向的动态类型实现了T接口类型所拥有的方法，则断言成功。h没有实现superhuman类型所定义的fly()方法，所以h.(superhuman)是断言失败的。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;h.(human)        type asertion (type conversion check) is %T\n&#34;</span>, <span style="color:#a6e22e">h</span>.(<span style="color:#a6e22e">human</span>))
	<span style="color:#75715e">//fmt.Printf(&#34;h.(superhuman) type asertion (type conversion check) is %T\n&#34;, h.(superhuman)) //panic: interface conversion: main.man is not main.superhuman: missing method fly
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s.(superhuman)   type assertion (type conversion check) is %T\n&#34;</span>, <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">superhuman</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s.(human)        type assertion (type conversion check) is %T\n&#34;</span>, <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">human</span>))
}
</code></pre></div><p><code>i.(T) type asertion (type conversion check) test</code><!-- raw HTML omitted --></p>
<p><code>T is a non-interface type:</code><!-- raw HTML omitted -->
<code>h.(man)          type asertion (type conversion check) is main.man</code><!-- raw HTML omitted -->
<code>s.(superman)     type assertion (type conversion check) is main.superman</code><!-- raw HTML omitted --></p>
<p><code>T is a interface type:</code><!-- raw HTML omitted -->
<code>h.(human)        type asertion (type conversion check) is main.man</code><!-- raw HTML omitted -->
<code>s.(superhuman)   type assertion (type conversion check) is main.superman</code><!-- raw HTML omitted -->
<code>s.(human)        type assertion (type conversion check) is main.superman</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/JK2vKX4NshX"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<p>利用第2个返回值判断类型断言是否成功，并防止类型断言失败时产生panic  //adm</p>
<p>类型断言是为了我们能更好的检查当前使用的接口变量是否符合我们要求的类型，如果转换类型不符合我们的要求，上述例子中(h.(superhuman))会直接使程序panic，<!-- raw HTML omitted -->
这样做在程序中不太优雅，幸好Go语言为类型断言的返回值提供了2个结果:<!-- raw HTML omitted -->
第1个是转换结果，转换成功的话，转换结果是i值的一份副本，转换失败的话，转换结果是转换类型的0值。<!-- raw HTML omitted -->
第2个是可选的bool类型的true或false转换结果，用于判断转换是否成功，并防止转换失败的程序进入panic<!-- raw HTML omitted --></p>
<p>一个interface{}类型的变量，默认值为nil，这个变量要转换成其他类型时都会失败, 如下面程序中的变量j。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i is&#34;</span>, <span style="color:#a6e22e">i</span>)

	<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">int</span>)               <span style="color:#75715e">//interface{}类型的i指向100时，会把100的默认类型转换为int整型。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i.(int):&#34;</span>, <span style="color:#a6e22e">x</span>) <span style="color:#75715e">//100
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">int</span>)               <span style="color:#75715e">//在上一步的基础上加入可选变量ok，用于判断类型断言是否成功。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i.(int):&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">//100 true
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//y := i.([]int)              //i的默认类型是int，这里用[]int作为断言类型肯定会断言失败，同时这里只用了1个返回结果y，程序会直接进入panic。
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//fmt.Println(&#34;i.([]int)&#34;, y) //panic: interface conversion: interface {} is int, not []int
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.([]<span style="color:#66d9ef">int</span>)               <span style="color:#75715e">//在上一步的基础上加入可选变量ok，用于判断类型断言是否成功。如果类型断言失败，则程序可以继续执行，不panic。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i.([]int):&#34;</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">//[] false
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">z</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">interface</span>{})               <span style="color:#75715e">//i的断言类型是interface{}时，因为interface{}没有任何方法, 可以理解为interface{}类型不用实现，或者i实现了interface{}类型。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i.(interface{}):&#34;</span>, <span style="color:#a6e22e">z</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">//100 true
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">interface</span>{} <span style="color:#75715e">//j为interface{}类型的变量，j的默认值为nil
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;j is&#34;</span>, <span style="color:#a6e22e">j</span>)

	<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">j</span>.(<span style="color:#66d9ef">int</span>)               <span style="color:#75715e">//测试j能否成功转换成int类型
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;j.(int):&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">//0 false 转换失败
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">j</span>.(<span style="color:#66d9ef">interface</span>{})               <span style="color:#75715e">//测试j能否成功转换成interface{}类型
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;j.(interface{}):&#34;</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">//&lt;nil&gt; false 转换失败
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>i is 100</code><!-- raw HTML omitted -->
<code>i.(int): 100</code><!-- raw HTML omitted -->
<code>i.(int): 100 true</code><!-- raw HTML omitted -->
<code>i.([]int): [] false</code><!-- raw HTML omitted -->
<code>i.(interface{}): 100 true</code><!-- raw HTML omitted --></p>
<p><code>j is &lt;nil&gt;</code><!-- raw HTML omitted -->
<code>j.(int): 0 false</code><!-- raw HTML omitted -->
<code>j.(interface{}): &lt;nil&gt; false</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/t5dUd4e8aEx"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h2 id="75-type-switch">7.5 type-switch</h2>
<p>type-switch语句是类型断言的增强与补充，type-switch与switch-case语句有些相似，type-switch的语句结构如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">SimpleStmt</span>; <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">TypeA</span>:
	<span style="color:#f92672">...</span>
<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">TypeB</span>, <span style="color:#a6e22e">TypeC</span>:
	<span style="color:#f92672">...</span>
<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">nil</span>:
	<span style="color:#f92672">...</span>
<span style="color:#66d9ef">default</span>:
	<span style="color:#f92672">...</span>
}
</code></pre></div><p>SimpleStmt在type-switch中是可选的。<!-- raw HTML omitted --></p>
<p>i是一个接口类型的变量，v是i的断言结果，注意i.(type)，与i.(T)中的T可以改成具体类型不同，这里必须写成type, 如下例中的x.(type)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">values</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">interface</span>{}{
		<span style="color:#ae81ff">456</span>, <span style="color:#e6db74">&#34;abc&#34;</span>, <span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">0.33</span>, int32(<span style="color:#ae81ff">789</span>),
		[]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>{}, <span style="color:#66d9ef">nil</span>,
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">values</span> {
		<span style="color:#75715e">// Here, v is declared once, but it denotes
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// different variables in different branches.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span>.(<span style="color:#66d9ef">type</span>) {

		<span style="color:#75715e">//case interface{}:
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//fmt.Println(&#34;\ninterface{} val: &#34;, v)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//fmt.Printf(&#34;interface{} type: %T\n&#34;, v)
</span><span style="color:#75715e"></span>
		<span style="color:#66d9ef">case</span> []<span style="color:#66d9ef">int</span>: <span style="color:#75715e">// a type literal
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nint slice:&#34;</span>, <span style="color:#a6e22e">v</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>: <span style="color:#75715e">// one type name
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nstring:&#34;</span>, <span style="color:#a6e22e">v</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">float64</span>, <span style="color:#66d9ef">int32</span>: <span style="color:#75715e">// multiple type names
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nnumber:&#34;</span>, <span style="color:#a6e22e">v</span>)

		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">bool</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nbool:&#34;</span>, <span style="color:#a6e22e">v</span>)

		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">nil</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nnil val: &#34;</span>, <span style="color:#a6e22e">v</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;nil type: %T\n&#34;</span>, <span style="color:#a6e22e">v</span>)

		<span style="color:#66d9ef">default</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nOthers val: &#34;</span>, <span style="color:#a6e22e">v</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Others type: %T\n&#34;</span>, <span style="color:#a6e22e">v</span>)
		}
	}
}
</code></pre></div><p><code>number: 456</code><!-- raw HTML omitted --></p>
<p><code>string: abc</code><!-- raw HTML omitted --></p>
<p><code>bool: true</code><!-- raw HTML omitted --></p>
<p><code>number: 0.33</code><!-- raw HTML omitted --></p>
<p><code>number: 789</code><!-- raw HTML omitted --></p>
<p><code>int slice: [1 2 3]</code><!-- raw HTML omitted --></p>
<p><code>Others val:  map[]</code><!-- raw HTML omitted -->
<code>Others type: map[int]bool</code><!-- raw HTML omitted --></p>
<p><code>nil val:  &lt;nil&gt;</code><!-- raw HTML omitted -->
<code>nil type: &lt;nil&gt;</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/1NYl6BGpQaK"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h2 id="76-">7.6 接口嵌入</h2>
<p>一个接口类型里可以嵌入另一个接口类型，但接口类型不能嵌套多个具有相同方法名的接口类型，也不能自己嵌套自己  //adm</p>
<p>比如下面的asian接口类型里嵌入了human接口类型，asian接口类型里同样也声明了fly() error方法，所以接口asian和接口superhuman
在效果上是一样的.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">human</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">man</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">man</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Man can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">superman</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can fly&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">superman</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;superman can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#75715e">//接口类型可以包裹其他接口类型，比如asian接口类型可以包含human接口类型，asian含有human拥有的所有方法。
</span><span style="color:#75715e"></span><span style="color:#75715e">//如果给asian再加上一个fly()的方法，那asian就成为超级亚洲人了。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">asian</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">human</span>
	<span style="color:#75715e">//superhuman //接口类型不能嵌套多个具有相同方法名的接口类型
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//asian //接口类型不能自己嵌套自己
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span>
}

<span style="color:#75715e">//flyman实现了fly()方法。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">flyman</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">flyman</span>) <span style="color:#a6e22e">swim</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;flyman can swim&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">flyman</span>) <span style="color:#a6e22e">walk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;flyman can walk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">flyman</span>) <span style="color:#a6e22e">talk</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;flyman can talk&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">flyman</span>) <span style="color:#a6e22e">fly</span>() <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Believe me I can fly, I am singing in the sky&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">asian</span>      <span style="color:#75715e">//a是超级亚洲人接口类型变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#75715e">//s代表超人类接口类型变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#a6e22e">flyman</span>     <span style="color:#75715e">//f是一个flyman类型的变量，flyman类型实现了asian接口类型的所有方法，flyman类型的变量f也具有flyman类型的所有方法。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>.(<span style="color:#a6e22e">human</span>) <span style="color:#75715e">//human是接口类型，a实现了human接口类型的所有方法，所以a.(human)断言成功
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a.(human): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">human</span>)  <span style="color:#75715e">//同上
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s.(human): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">a</span>.(<span style="color:#a6e22e">superhuman</span>) <span style="color:#75715e">//superhuman是接口类型，a实现了superhuman接口类型的所有方法(flyman会fly了)，所以a.(superhuman)断言成功
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a.(superhuman): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">superhuman</span>)  <span style="color:#75715e">//同上
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s.(superhuman): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#75715e">//_, ok = a.(man) //man是一个非接口类型，a的方法要和man的方法实现完全一致才能断言成功，man没有实现fly接口，所以a.(man)断言失败。 impossible type assertion: man does not implement asian (missing fly method)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//fmt.Println(&#34;a.(man): &#34;, ok)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//_, ok = s.(man) //同上impossible type assertion:man does not implement superhuman (missing fly method)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//fmt.Println(&#34;s.(man): &#34;, ok)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">a</span>.(<span style="color:#a6e22e">superman</span>) <span style="color:#75715e">//superman是一个非接口类型，a的动态类型是flyman，不是superman，所以a.(superman)断言失败
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a.(superman): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">superman</span>) <span style="color:#75715e">//同上
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s.(superman): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">a</span>.(<span style="color:#a6e22e">flyman</span>) <span style="color:#75715e">//flyman是一个非接口类型，a的动态类型是flyman，所以a.(flyman)断言成功
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a.(flyman): &#34;</span>, <span style="color:#a6e22e">ok</span>)

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">s</span>.(<span style="color:#a6e22e">flyman</span>) <span style="color:#75715e">//同上
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;s.(flyman): &#34;</span>, <span style="color:#a6e22e">ok</span>)
}
</code></pre></div><p><code>a.(human):  true</code><!-- raw HTML omitted -->
<code>s.(human):  true</code><!-- raw HTML omitted -->
<code>a.(superhuman):  true</code><!-- raw HTML omitted -->
<code>s.(superhuman):  true</code><!-- raw HTML omitted -->
<code>a.(superman):  false</code><!-- raw HTML omitted -->
<code>s.(superman):  false</code><!-- raw HTML omitted -->
<code>a.(flyman):  true</code><!-- raw HTML omitted -->
<code>s.(flyman):  true</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/CzUcp96U9HR"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h2 id="77-">7.7 接口变量比较</h2>
<p>接口变量进行比较，结果相等的条件只有如下2个：<!-- raw HTML omitted --></p>
<ol>
<li>2个接口变量的值均为nil<!-- raw HTML omitted --></li>
<li>2个接口变量具有相同的动态类型和动态值<!-- raw HTML omitted --></li>
</ol>
<p>将7.6中的main函数改成如下可以看到接口变量比较结果的例子  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">asian</span>      <span style="color:#75715e">//a是超级亚洲人接口类型变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">superhuman</span> <span style="color:#75715e">//s代表超人类接口类型变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#a6e22e">flyman</span>     <span style="color:#75715e">//f是一个flyman类型的变量，flyman类型实现了asian接口类型的所有方法，flyman类型的变量f也具有flyman类型的所有方法。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sm</span> <span style="color:#a6e22e">superman</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a:&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;s:&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34; a == s&#34;</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>) <span style="color:#75715e">//a: &lt;nil&gt; s: &lt;nil&gt;  a == s true. a 和 s的值均为nil, 符合条件1
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a:&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;s:&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34; a == s&#34;</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>) <span style="color:#75715e">//a: {} s: {}  a == s true. a 和 s均指向同一个变量f，符合条件2
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">f</span>
	<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">sm</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a:&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;s:&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34; a == s&#34;</span>, <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>) <span style="color:#75715e">//a: {} s: {}  a == s false. f和sm虽然均有相同的方法实现，但是它们对于a和s来说属于不同的动态类型和动态值，所以比较结果不同， 不符合条件2。
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>a: &lt;nil&gt; s: &lt;nil&gt;  a == s true</code><!-- raw HTML omitted -->
<code>a: {} s: {}  a == s true</code><!-- raw HTML omitted -->
<code>a: {} s: {}  a == s false</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/U7_ncGQz_jS"><strong>⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  P L A Y A R O U N D 📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️  🧰  📟 ⚙️</strong></a></p>
<h1 id="8">8.通道</h1>
<p>通过共享内存通信和通过通信来共享内存是2种不同的编程方式。通过共享内存通信需要使用互斥锁之类的同步方式来防止数据竞争，
而通过通信来共享内存则可以通过通道channel的方式来实现，即通过channel(通道)来实现goroutine(并发)之间的共享内存。</p>
<h2 id="81-">8.1 什么是通道</h2>
<p>通道(channel)的关键字为chan，可以把通道看作FIFO(first in first out)一样的数据队列。同slice，map一样，
chan是Go语言的内置类型，使用时不需要导入包，但是像其他的同步方式（比如WaitGroup）则需要导入sync或sync/atomic包。
chan有不同的类型，chan传输的数据类型要和chan的类型一致，假设T是chan的类型：<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<blockquote>
</blockquote>
<p><code>chan T</code>   表示一个双向通道，即可以往通道发送T类型的数据，也可以从通道读取T类型的数据。<!-- raw HTML omitted -->
<code>chan&lt;- T</code>表示一个只能往通道发送T类型数据的单向通道。从此通道里读取数据会引起编译错误❌<!-- raw HTML omitted -->
<code>&lt;-chan T</code>表示一个只能从通道读取T类型数据的单向通道。往此通道里发送数据会引起编译错误❌<!-- raw HTML omitted --></p>
<p><code>chan T</code>类型的通道值可以隐式的转换为<code>chan&lt;- T</code>或<code>&lt;-chan T</code>类型的值。<!-- raw HTML omitted -->
<code>chan&lt;- T</code>和<code>&lt;-chan T</code>类型的值不能转换为<code>chan T</code>类型的值;<!-- raw HTML omitted -->
<code>chan&lt;- T</code>和<code>&lt;-chan T</code>类型的值也不能互相转换。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//声明一个数据类型为int的双向通道变量bidirCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bidirCh</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// or bidirCh := chan int(nil)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//声明一个数据类型为int的send only的单向通道变量sendOnlyCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sendOnlyCh</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>

	<span style="color:#75715e">//声明一个数据类型为int的receive only的单向通道变量receiveOnlyCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">receiveOnlyCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;bidirCh is nil? %t\n&#34;</span>, <span style="color:#a6e22e">bidirCh</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;bidirCh type is: %#v\n\n&#34;</span>, <span style="color:#a6e22e">bidirCh</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sendOnlyCh is nil? %t\n&#34;</span>, <span style="color:#a6e22e">sendOnlyCh</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sendOnlyCh type is: %#v\n\n&#34;</span>, <span style="color:#a6e22e">sendOnlyCh</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;receiveOnlyCh is nil? %t\n&#34;</span>, <span style="color:#a6e22e">receiveOnlyCh</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;receiveOnlyCh type is: %#v\n&#34;</span>, <span style="color:#a6e22e">receiveOnlyCh</span>)

	<span style="color:#75715e">//chan int 型的双向通道的变量可以隐式的转换为chan&lt;- int或&lt;-chan int型的单向通道的变量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendOnlyCh</span> = <span style="color:#a6e22e">bidirCh</span>    <span style="color:#75715e">//也可显式地转换:  sendOnlyCh := (chan&lt;- int)(bidirCh)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">receiveOnlyCh</span> = <span style="color:#a6e22e">bidirCh</span> <span style="color:#75715e">//也可显式地转换:  receiveOnlyCh := (&lt;-chan int)(bidirCh)
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>bidirCh is nil? true</code><!-- raw HTML omitted -->
<code>bidirCh type is: (chan int)(nil)</code><!-- raw HTML omitted --></p>
<p><code>sendOnlyCh is nil? true</code><!-- raw HTML omitted -->
<code>sendOnlyCh type is: (chan&lt;- int)(nil)</code><!-- raw HTML omitted --></p>
<p><code>receiveOnlyCh is nil? true</code><!-- raw HTML omitted -->
<code>receiveOnlyCh type is: (&lt;-chan int)(nil)</code><!-- raw HTML omitted --></p>
<p><a href=""><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<h2 id="82-">8.2 创建通道</h2>
<p>8.1的例子中我们创建的3个通道bidirCh, sendOnlyCh和receiveOnlyCh的值均为nil，即系统为这3个声明的变量分配了地址，
但变量内部的成员值还均为0值。我们可以用make()函数为这些通道分配缓存大小。<!-- raw HTML omitted --></p>
<p>make(chan int, 10) //创建一个容量为10类型为int的通道<!-- raw HTML omitted -->
make(chan int, 0)  //创建一个容量为0类型为int的通道<!-- raw HTML omitted --></p>
<p>make函数的第二个参数是可选的，默认是0，所以make(chan int, 0)也可以写成make(chan int)。容量为0的通道称为无缓冲的通道，否则称之为有缓冲的通道<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//声明一个数据类型为int的双向通道变量bidirCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bidirCh</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// or bidirCh := chan int(nil)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//声明一个数据类型为int的send only的单向通道变量sendOnlyCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sendOnlyCh</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>

	<span style="color:#75715e">//声明一个数据类型为int的receive only的单向通道变量receiveOnlyCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">receiveOnlyCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>

	<span style="color:#75715e">//将bidircCh分配成一个无缓冲的双向通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bidirCh</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">//或者bidirCh = make(chan int)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//将sendOnlyCh分配成一个有20个整数缓冲的send only的通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendOnlyCh</span> = make(<span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">20</span>)

	<span style="color:#75715e">//将receiveOnlyCh分配成一个有30个整数缓冲的receive only的通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">receiveOnlyCh</span> = make(<span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">30</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;bidirCh is nil? %t\n&#34;</span>, <span style="color:#a6e22e">bidirCh</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sendOnlyCh is nil? %t\n&#34;</span>, <span style="color:#a6e22e">sendOnlyCh</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;receiveOnlyCh is nil? %t\n\n&#34;</span>, <span style="color:#a6e22e">receiveOnlyCh</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;bidirCh len %d cap:%d\n&#34;</span>, len(<span style="color:#a6e22e">bidirCh</span>), cap(<span style="color:#a6e22e">bidirCh</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sendOnlyCh len %d cap:%d\n&#34;</span>, len(<span style="color:#a6e22e">sendOnlyCh</span>), cap(<span style="color:#a6e22e">sendOnlyCh</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;receiveOnlyCh len %d cap:%d\n\n&#34;</span>, len(<span style="color:#a6e22e">receiveOnlyCh</span>), cap(<span style="color:#a6e22e">receiveOnlyCh</span>))

	<span style="color:#75715e">//chan int 型的双向通道的变量可以隐式的转换为chan&lt;- int或&lt;-chan int型的单向通道的变量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendOnlyCh</span> = <span style="color:#a6e22e">bidirCh</span>    <span style="color:#75715e">//也可显式地转换:  sendOnlyCh := (chan&lt;- int)(bidirCh)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">receiveOnlyCh</span> = <span style="color:#a6e22e">bidirCh</span> <span style="color:#75715e">//也可显式地转换:  receiveOnlyCh := (chan&lt;- int)(bidirCh)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//注意: 这时的sendOnlyCh和receiveOnlyCh均是由bidirCh转换而来，它们的容量cap已变成bidirCh的容量。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sendOnlyCh len %d cap:%d\n&#34;</span>, len(<span style="color:#a6e22e">sendOnlyCh</span>), cap(<span style="color:#a6e22e">sendOnlyCh</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;receiveOnlyCh len %d cap:%d\n&#34;</span>, len(<span style="color:#a6e22e">receiveOnlyCh</span>), cap(<span style="color:#a6e22e">receiveOnlyCh</span>))
}
</code></pre></div><p><code>bidirCh is nil? false</code><!-- raw HTML omitted -->
<code>sendOnlyCh is nil? false</code><!-- raw HTML omitted -->
<code>receiveOnlyCh is nil? false</code><!-- raw HTML omitted --></p>
<p><code>bidirCh len 0 cap:0</code><!-- raw HTML omitted -->
<code>sendOnlyCh len 0 cap:20</code><!-- raw HTML omitted -->
<code>receiveOnlyCh len 0 cap:30</code><!-- raw HTML omitted --></p>
<p><code>sendOnlyCh len 0 cap:0</code><!-- raw HTML omitted -->
<code>receiveOnlyCh len 0 cap:0</code><!-- raw HTML omitted --></p>
<p><a href=""><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<h2 id="83-">8.3 发送/接收数据</h2>
<p><strong>对通道的标识符&lt;-的说明:<!-- raw HTML omitted --></strong></p>
<ol>
<li>把&lt;-放在chan的左边或右边表示通道类型是发送还是接收，比如：<!-- raw HTML omitted -->
<code>var sch chan&lt;- int</code>：&lt;-指向通道，代表sch是一个send only通道类型的变量<!-- raw HTML omitted -->
<code>var rch &lt;-chan int</code>:   &lt;-源自通道，代表rch是一个receive only通道类型的变量<!-- raw HTML omitted --></li>
<li>把&lt;-放在通道变量的左面或右面表示对通道进行接收或发送，比如：<!-- raw HTML omitted -->
<code>sch &lt;- 5</code>: &lt;-指向sch，表示将数组5发送到sch通道<!-- raw HTML omitted -->
<code>i &lt;- sch</code>: &lt;-源自sch，表示从sch通道里接收一个数字到变量i<!-- raw HTML omitted --></li>
</ol>
<p>下面的程序演示了从一个无缓冲的bidirCh通道发送并接收数据的过程，sender用来向bidirCh发送数据，
receiver用来从bidirCh接收数据。由于bidirCh是无缓冲的通道，sender每发完一个数据后都会block
在bidirCh端等待数据被receiver接收，receiver接收完数据后也会block在bidirCh端等待sender再次
发送数据，依次循环，直到sender和receiver把切片s消耗完为止。<!-- raw HTML omitted -->
程序的第35行和38行分别用关键字go调用了sender和receiver的函数，这相当于在程序里起了一个“线程”，
这里我们叫goroutine，main函数也是一个goroutine，我们称之为main goroutine。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#75715e">//fmt.Println(&#34;\nsend block&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;send %d\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> {
		<span style="color:#75715e">//fmt.Println(&#34;\nrecv block&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;recv %d\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//声明一个数据类型为int的双向通道变量bidirCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bidirCh</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// or bidirCh := chan int(nil)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//为bidircCh分配一个无缓冲的双向通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bidirCh</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">//或者bidirCh = make(chan int)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}

	<span style="color:#75715e">//启动sender的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">bidirCh</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">//启动receiver的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">bidirCh</span>)

	<span style="color:#75715e">//让main goroutine 延迟5秒退出，以便等待sender和receiver的goroutine完成。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>)
}
</code></pre></div><p><code>recv 5</code><!-- raw HTML omitted -->
<code>send 5</code><!-- raw HTML omitted -->
<code>send 4</code><!-- raw HTML omitted -->
<code>recv 4</code><!-- raw HTML omitted -->
<code>recv 3</code><!-- raw HTML omitted -->
<code>send 3</code><!-- raw HTML omitted -->
<code>send 2</code><!-- raw HTML omitted -->
<code>recv 2</code><!-- raw HTML omitted -->
<code>recv 1</code><!-- raw HTML omitted -->
<code>send 1</code><!-- raw HTML omitted -->
<code>send 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted --></p>
<p>send和recv对数字的发送与接收都是成对出现的，说明无缓冲的通道bidirCh具有同步的效果，
在Go语言中无缓冲的通道也称作<strong>同步通道</strong>。<!-- raw HTML omitted -->
send和recv在处理不同的数字时它们出现的先后顺序不同，比如数字1，3，5是send在recv前，
数字2，4是recv在send前，对于这种x事件和y事件发生顺序不固定的情况，我们就叫做并发。</p>
<p>在打印中可以看到一些奇怪的现象，对于数字1，3，5的操作均是send在recv前，但是2和4的recv在send前。
以recv2在send2之前为例，这并不是说sender还未发送数字2时receiver就已经接收到了数字2，而是因为在
sender发送完数字1之后<code>ch &lt;- v</code>会block住sender的goroutine，继而sender的goroutine从运行状态进入休眠状态，
然后receiver的goroutine被唤醒并接收sender发送到通道的数字1，之后receiver的<code>v := &lt;-ch</code>会block住receiver
的goroutine，这个操作发生在sender发送2之前，在sender发送数字2之前receiver就已经block在通道的另一端准备好了接收的操作，</p>
<p><a href=""><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<h2 id="84-">8.4 关闭通道</h2>
<p>假设通道变量为ch,关闭通道的操作为： close(ch), 使用close()函数需要注意以下几点：<!-- raw HTML omitted --></p>
<ol>
<li>close一个值为nil的通道会导致panic。<!-- raw HTML omitted --></li>
<li>close一个已经close()的通道会导致panic异常。<!-- raw HTML omitted --></li>
<li>在向一个已经close()的通道发送数据时会导致panic。<!-- raw HTML omitted --></li>
<li>close()不能关闭receive-only类型的通道。<!-- raw HTML omitted --></li>
<li>从一个已经close()的通道接收数据时会产生无尽的0值。<!-- raw HTML omitted --></li>
</ol>
<p>下例程序的注释标出了以上item1 ～ item4的4种错误操作，item5的无尽0值可以看下例程序的打印输出。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#75715e">//fmt.Println(&#34;\nsend block&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;send %d\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
	close(<span style="color:#a6e22e">ch</span>)
	<span style="color:#75715e">//close(ch) //item2 ❌ panic: close of closed channel
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- 99  //item3 ❌ panic: send on closed channel
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> {
		<span style="color:#75715e">//fmt.Println(&#34;\nrecv block&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//close(ch) //item4 ❌ invalid operation: close(ch) (cannot close receive-only channel)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;recv %d\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//声明一个通道数据类型为int的双向通道bidirCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bidirCh</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// or bidirCh := chan int(nil)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//close(bidirCh) //item1 ❌ panic: close of nil channel
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//将bidircCh分配成一个无缓冲的双向通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bidirCh</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">//或者bidirCh = make(chan int)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}

	<span style="color:#75715e">//启动sender的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">bidirCh</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">//启动receiver的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">bidirCh</span>)

	<span style="color:#75715e">//让main goroutine 延迟5秒退出，以便等待sender和receiver的goroutine完成。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>)
}
</code></pre></div><p><code>recv 5</code><!-- raw HTML omitted -->
<code>send 5</code><!-- raw HTML omitted -->
<code>send 4</code><!-- raw HTML omitted -->
<code>recv 4</code><!-- raw HTML omitted -->
<code>recv 3</code><!-- raw HTML omitted -->
<code>send 3</code><!-- raw HTML omitted -->
<code>send 2</code><!-- raw HTML omitted -->
<code>recv 2</code><!-- raw HTML omitted -->
<code>recv 1</code><!-- raw HTML omitted -->
<code>send 1</code><!-- raw HTML omitted -->
<code>send 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted -->
<code>recv 0</code><!-- raw HTML omitted -->
<code>... </code><!-- raw HTML omitted --></p>
<p>上面的打印出现了很多<code>recv 0</code>的打印，我们无法判断究竟哪一个是sender发送的那些是通道close()之后读出来的，
下一节的例子会解决这个问题。</p>
<p><a href="https://play.golang.org/p/kkGOj6tG-sJ"><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<p>Go语言中的通道在使用完毕后不必非得使用close()函数来关闭通道，GC会自动检测并回收不再被引用的通道，
那close()函数的作用是什么呢: close()可以通知通道的接收者在接收到某一个数据后后续再接收的数据将不再有效。<!-- raw HTML omitted -->
事实上从通道接收数据还有一个可选的bool变量，用于判断这个数据是否是从从通道里读取出来的，这样就能解决上面遇到的
不确定哪个<code>recv 0</code> 是sender发送的问题。</p>
<p>下面的例子里的接收者将判断从当前通道里读取数据如果不是true的话将终止接收通道的数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#75715e">//fmt.Println(&#34;\nsend block&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;send %d\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
	close(<span style="color:#a6e22e">ch</span>)
	<span style="color:#75715e">//close(ch) //item2 ❌ panic: close of closed channel
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- 99  //item3 ❌ panic: send on closed channel
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> {
		<span style="color:#75715e">//fmt.Println(&#34;\nrecv block&#34;)
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//close(ch) //item4 ❌ invalid operation: close(ch) (cannot close receive-only channel)
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;recv %d %t\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//声明一个通道数据类型为int的双向通道bidirCh
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bidirCh</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// or bidirCh := chan int(nil)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//close(bidirCh) //item1 ❌ panic: close of nil channel
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//将bidircCh分配成一个无缓冲的双向通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bidirCh</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">//或者bidirCh = make(chan int)
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}

	<span style="color:#75715e">//启动sender的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">bidirCh</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">//启动receiver的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">bidirCh</span>)

	<span style="color:#75715e">//让main goroutine 延迟5秒退出，以便等待sender和receiver的goroutine完成。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>)
}
</code></pre></div><p><code>recv 5 true</code><!-- raw HTML omitted -->
<code>send 5</code><!-- raw HTML omitted -->
<code>send 4</code><!-- raw HTML omitted -->
<code>recv 4 true</code><!-- raw HTML omitted -->
<code>recv 3 true</code><!-- raw HTML omitted -->
<code>send 3</code><!-- raw HTML omitted -->
<code>send 2</code><!-- raw HTML omitted -->
<code>recv 2 true</code><!-- raw HTML omitted -->
<code>recv 1 true</code><!-- raw HTML omitted -->
<code>send 1</code><!-- raw HTML omitted -->
<code>send 0</code><!-- raw HTML omitted -->
<code>recv 0 true</code><!-- raw HTML omitted --></p>
<p>使用close()函数并配合接收者对接收数据的true/false的判断，可以有效控制通过通道要发送或接收的数据。</p>
<p>对于在本节刚开始提到的以下3种对通道的操作会导致panic的情况，都可以先从通道读取出一个数据并判断其
是否为true的方式再执行以下3种close通道的方式，以避免产生panic:<!-- raw HTML omitted --></p>
<ol>
<li>close一个值为nil的通道会导致panic。<!-- raw HTML omitted --></li>
<li>close一个已经close()的通道会导致panic异常。<!-- raw HTML omitted --></li>
<li>在向一个已经close()的通道发送数据时会导致panic。<!-- raw HTML omitted --></li>
</ol>
<p><a href="https://play.golang.org/p/kkGOj6tG-sJ"><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<h2 id="84-timesleep">8.4 用通道替换time.Sleep</h2>
<p>在main函数结尾加一个<code>time.Sleep(time.Second * 5)</code>是为了调试sender和receiver的goroutine，但是正式编写程序时这个time.Sleep
的延时不利于程序的快速🔜执行，所以我们可以往receiver的goroutine传入一个send only的done通道，之后main函数阻塞在done的一端
读取数据。当receiver函数接收完ch通道的数据后，可以像done通道发送一个字符串，然后main函数就从done通道接收到了receiver写入
的数据，整个程序结束。<!-- raw HTML omitted -->
这种goroutine像通道写入数据并由main goroutine读取的方法也适合解决go 启动goroutine无法取得返回值的问题。goroutine可以通过
像一个通道写入想要返回🔙给main goroutine的数据并由main goroutine读取即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">v</span>
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;send %d\n&#34;</span>, <span style="color:#a6e22e">v</span>)
	}
	close(<span style="color:#a6e22e">ch</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">done</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">for</span> {
		<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;recv %d %t\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
	<span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;**********************************&#34;</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bidirCh</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>)

	<span style="color:#a6e22e">bidirCh</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}

	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">bidirCh</span>, <span style="color:#a6e22e">s</span>)

	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">bidirCh</span>, <span style="color:#a6e22e">done</span>)

	<span style="color:#75715e">//time.Sleep(time.Second * 5)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//Replace time.Sleep() statement with &lt;-done and
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//print the receiving string from done channel.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>)
}
</code></pre></div><p><code>recv 5 true</code><!-- raw HTML omitted -->
<code>send 5</code><!-- raw HTML omitted -->
<code>send 4</code><!-- raw HTML omitted -->
<code>recv 4 true</code><!-- raw HTML omitted -->
<code>recv 3 true</code><!-- raw HTML omitted -->
<code>send 3</code><!-- raw HTML omitted -->
<code>send 2</code><!-- raw HTML omitted -->
<code>recv 2 true</code><!-- raw HTML omitted -->
<code>recv 1 true</code><!-- raw HTML omitted -->
<code>send 1</code><!-- raw HTML omitted -->
<code>send 0</code><!-- raw HTML omitted -->
<code>recv 0 true</code><!-- raw HTML omitted -->
<code>**********************************</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/C3fkUTPXmRi"><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<h2 id="85-">8.5 多个发送端</h2>
<h2 id="85-outofmemorybug">8.5 一种能产生outofmemory的bug</h2>
<h2 id="86-channel">8.6 选取合适的channel缓存大小</h2>
<h2 id="83--1">8.3 通道相关的操作</h2>
<p>通道的操作通常涉及：1. 创建，2. 写入数据，3. 获得通道长度和容量，4. 读取数据，8. 关闭通道。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)

	<span style="color:#75715e">//1. 创建： 创建一个缓冲为5的通道ch
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(ch):%2d  cap(ch):%2d\n&#34;</span>, len(<span style="color:#a6e22e">ch</span>), cap(<span style="color:#a6e22e">ch</span>))<span style="color:#75715e">//len(ch): 0  cap(ch): 5
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//2. 写入： 往通道ch里发送数据
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">3</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">4</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">5</span>

	<span style="color:#75715e">//3.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 长度
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 容量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(ch):%2d  cap(ch):%2d\n&#34;</span>, len(<span style="color:#a6e22e">ch</span>), cap(<span style="color:#a6e22e">ch</span>))<span style="color:#75715e">//len(ch): 0  cap(ch): 5
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//❌ ch &lt;- 6 //通道已满(len(ch) == len(cap))，再像通道写入数据会产生错误：fatal error: all goroutines are asleep - deadlock!
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//4. 读取
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">3</span>] = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">4</span>] = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(ch):%2d  cap(ch):%2d\n&#34;</span>, len(<span style="color:#a6e22e">ch</span>), cap(<span style="color:#a6e22e">ch</span>))<span style="color:#75715e">//len(ch): 0  cap(ch): 5
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//❌ s[5] = &lt;-ch //通道已空(len(ch) == 0)，再从通道读取数据会产生错误：fatal error: all goroutines are asleep - deadlock!
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#75715e">//8. 关闭
</span><span style="color:#75715e"></span>	close(<span style="color:#a6e22e">ch</span>)
}
</code></pre></div><p><code>len(ch): 0  cap(ch): 5</code><!-- raw HTML omitted -->
<code>len(ch): 5  cap(ch): 5</code><!-- raw HTML omitted -->
<code>len(ch): 0  cap(ch): 5</code><!-- raw HTML omitted -->
<code>[1 2 3 4 5 0 0 0 0 0]</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/HCrPO1n5mlc"><strong>🍏〰️🍎〰️🍐〰️🍊〰️🍋〰️🍌〰️🍉 P L A Y A R O U N D 〰️🍇〰️🍓〰️🍈〰️🍒〰️🍑〰️🥭 〰️🥝</strong></a></p>
<h2 id="84--1">8.4 通道会崩溃的几种情况</h2>
<h1 id="9-parallelism">9. 并发与并行（parallelism）</h1>
<h2 id="heading"></h2>
<h2 id="91-concurrency">9.1. 并发（concurrency）</h2>
<p>Go语言中的并发主要是通过goroutine来实现，goroutine是一种超轻量的thread。
Go语言的goroutine用的是<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">M-P-G模型</a>:
M代表系统thread， P代表逻辑CPU，G代表goroutine。<!-- raw HTML omitted -->
Go语言的运行时(runtime)会为每个物理CPU分配一个系统thread(下图中的M0)和一个逻辑CPU（下图中的P0），
并将这个逻辑CPU绑定到系统thread上（下图中的P0被绑定到了M0上）。
当有goroutine要运行的时候，运行时会将goroutine放到逻辑CPU（下图的P0）的等待队列中（下图中的G1, G2, G3, G4, G5）。
同一时刻，一个逻辑CPU（下图的P0）只能处理一个goroutine（下图中的G0正运行在P0上），运行队列中的其他goroutine
处于等待状态（下图中的G1, G2, G3, G4, G5处于等待队列），当当前goroutine(G0)的时间片用完后，
当前goroutine(G0)进入等待队列，调度器会从等待队列中挑选一个最新的goroutine（G1）交给逻辑CPU(P0）来执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">M0
|
|
|
P0 &lt;----等-待-队-列----G1--G2--G3--G4--G5---&lt;----
|						|
运						|
|						|
行						|
|						|
G0 -&gt;----回-到-等-待-队-列--------&gt;---------&gt;----
</code></pre></div><p>当一个goroutine执行了一个阻塞的系统调用时(比如G0处于阻塞状态)，调度器会将G0绑定到M0上，M0、G0均与P0分离，
调度器会为P0重新分配一个系统thead M1，并将P0绑定到M1上，此时P0会处理等待队列中的其他goroutine(比如G1)，
待G0阻塞完毕后，G0会重新回到P0的等待队列中等待执行，M0会被系统保存好，以便后续使用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">M0
|
|
|
G0<span style="color:#f92672">(</span>阻塞状态<span style="color:#f92672">)</span>
1. G0处于阻塞状态被绑定到M0上，M0、G0均与P0分离


M1
|
|
|
P0 &lt;----等-待-队-列----G2--G3--G4--G5-------&lt;----
|						|
运						|
|						|
行						|
|						|
G1 -&gt;----回-到-等-待-队-列--------&gt;---------&gt;----
2. 调度器为G1重新分配了一个系统线程M1， P0执行等待队列中的其他goroutine


M1
|
|
|
P0 &lt;----等-待-队-列----G3--G4--G5--G1--G0---&lt;----
|						|
运						|
|						|
行						|
|						|
G2 -&gt;----回-到-等-待-队-列--------&gt;---------&gt;----
3. G0阻塞完毕，重新回到P0的等待队列中


M0
|
|
|
4. M0被系统保存，以便后续使用。
</code></pre></div><p>GO 1.5版本之后会为每个物理CPU分配一个逻辑CPU，1.5版本之前运行时只给Go的应用程序分配一个逻辑CPU，即使只有一个逻辑CPU，
GO仍然可以以神奇的性能和效率，并发调度无数个goroutine。</p>
<p>Go程序中的main函数就是一个goroutine，如果要启动其他的gotoutine只需在调用的函数前面加上一个go关键字即可，如下示例:</p>
<p>goroutine简单示例  //adm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;log&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">routineTest</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">times</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">times</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">SetFlags</span>(<span style="color:#ae81ff">0</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">routineTest</span>(<span style="color:#e6db74">&#34;watching TV&#34;</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">routineTest</span>(<span style="color:#e6db74">&#34;coding&#34;</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
}
</code></pre></div><p><code>watching TV</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted --></p>
<p>在main函数的最后加入time.Sleep(5 * time.Second)不利于更多goroutine的调用，所幸同步机制能改变这一现状, 下面的小节将介绍go语言中的多种并发同步机制。</p>
<p><a href="https://play.golang.org/p/_xz8XxNcDIh"><strong>⚽️ 🏀 🏈 ⚾️ 🥎  🏐 🏉 🎾 🥏  🎱  P L A Y A R O U N D  🏓 🏸 🏏 🏹 🥊 🥋 🎽 ⛸  🥌 🛷 🛹  ⛳️</strong></a></p>
<h2 id="92-waitgroup">9.2 并发同步之WaitGroup</h2>
<p>WaitGroup有3个方法：Add, Done和Wait<!-- raw HTML omitted -->
Add方法的参数为要执行的goroutine数量<!-- raw HTML omitted -->
Done方法用于通知当前goroutine已经执行完毕<!-- raw HTML omitted -->
Wait方法用于goroutine的调用者等待goroutine执行完成，goroutine的执行完成由Done方法通知给Wait<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;log&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">routineTest</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">times</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">times</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">SetFlags</span>(<span style="color:#ae81ff">0</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">routineTest</span>(<span style="color:#e6db74">&#34;watching TV&#34;</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">routineTest</span>(<span style="color:#e6db74">&#34;coding&#34;</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><p><code>coding</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>coding</code><!-- raw HTML omitted -->
<code>watching TV</code><!-- raw HTML omitted --></p>
<p>上述程序中main函数开始执行时处于running的状态，当main函数执行完2个&quot;go routineTest&quot;语句后，这2个routineTest的goroutine处于running状态，
之后main函数执行wg.Wait()，wg.Wait()使main函数进入block状态。当routineTest执行到time.Sleep()语句时，goroutine处在staying in running
的状态(也可以理解为处在queuing状态)，当2个routineTest都执行到wg.Done()的时候，routineTest从running状态退出，然后回到main函数，
main函数从block状态恢复到running状态，然后再从running状态退出。goroutine只能从running状态退出，main程序也是goroutine。</p>
<p><a href="https://play.golang.org/p/0LuRQas0CTa"><strong>⚽️ 🏀 🏈 ⚾️ 🥎  🏐 🏉 🎾 🥏  🎱  P L A Y A R O U N D  🏓 🏸 🏏 🏹 🥊 🥋 🎽 ⛸  🥌 🛷 🛹  ⛳️</strong></a></p>
<h2 id="92-channel">9.2 并发同步之channel</h2>
<p><a href="https://play.golang.org/p/0LuRQas0CTa"><strong>⚽️ 🏀 🏈 ⚾️ 🥎  🏐 🏉 🎾 🥏  🎱  P L A Y A R O U N D  🏓 🏸 🏏 🏹 🥊 🥋 🎽 ⛸  🥌 🛷 🛹  ⛳️</strong></a></p>
<h1 id="10-">10 控制流程</h1>
<p>除了break, continue, goto代码跳转语句, go还支持fallthrough。<!-- raw HTML omitted -->
除了if-else，2-6均可使用break跳出控制流。<!-- raw HTML omitted -->
2和3叫做循环控制流语句，我们可以使用continue提前结束当前的循环，以进入下一个循环。<!-- raw HTML omitted --></p>
<h2 id="101-if">10.1 if条件执行</h2>
<p>if语句的语法如下，if后面跟<code>SimpleStmt; Condition</code>。  SimpleStmt是Go中SimpleStatement的简称，SimpleStmt可以省略。Condition是布尔类型的表达式，不能省略。else语句也可以省略<!-- raw HTML omitted -->
if会根据Condition的结果来条件执行后面的语句块。如果Condition为true，则执行if分支的语句块; 如果Condition为false，则执行else语句块或后续的代码。<!-- raw HTML omitted --></p>
<blockquote>
</blockquote>
<p>if SimpleStmt; Condition {<!-- raw HTML omitted -->
    // do something<!-- raw HTML omitted -->
} else {<!-- raw HTML omitted -->
    // do something<!-- raw HTML omitted -->
}<!-- raw HTML omitted --></p>
<p><strong>SimpleStatement</strong></p>
<p>Go中的SimpleStatement（简称SimpleStmt）分为以下6种情况：<!-- raw HTML omitted --></p>
<ol>
<li>空语句。对，就是简单的什么都没有<!-- raw HTML omitted --></li>
<li>通道发送/接收操作。 比如 ch&lt;-i或i&lt;-ch <!-- raw HTML omitted --></li>
<li>++或&ndash;，加加或减减的操作。 比如 i++或i&ndash; <!-- raw HTML omitted --></li>
<li>赋值语句。 比如 i = 1<!-- raw HTML omitted --></li>
<li>短变量声明。比如 i := 1<!-- raw HTML omitted --></li>
<li>表达式语句。比如 一元操作符(+ - ! ^ * &amp; &lt;-)相关的表达式，类型转换，断言，函数/方法的调用等<!-- raw HTML omitted --></li>
</ol>
<p>这里主要是为了展示if-else控制流的SimpleStmt的 6种情况，部分if语句的Condition直接使用了true的布尔值。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myint</span> <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">mi</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myint</span>) {
	<span style="color:#f92672">*</span><span style="color:#a6e22e">mi</span> = <span style="color:#ae81ff">3</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">mi</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myint</span>) <span style="color:#a6e22e">mymethod</span>() {
	<span style="color:#f92672">*</span><span style="color:#a6e22e">mi</span> = <span style="color:#ae81ff">4</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)

	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt1 空语句&#34;</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">5</span>; <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt2 通道发送 ch &lt;- 5&#34;</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>; <span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt2 通道接收 _, ok = &lt;-ch&#34;</span>, <span style="color:#a6e22e">ok</span>)
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> = new(<span style="color:#66d9ef">int</span>)
	<span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span> = <span style="color:#ae81ff">5</span>
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span><span style="color:#f92672">++</span>; <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt3 加加减减 *ptr++&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span><span style="color:#f92672">--</span>; <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt3 加加减减 *ptr--&#34;</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span>)
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">1</span>; <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt4 赋值语句 i =&#34;</span>, <span style="color:#a6e22e">i</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt5 短变量声明 x := &#34;</span>, <span style="color:#a6e22e">x</span>)
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mi</span> <span style="color:#a6e22e">myint</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mi</span>); <span style="color:#a6e22e">mi</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt6 函数调用 myfunc(&amp;mi), mi&#34;</span>, <span style="color:#a6e22e">mi</span>)
	}

	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mi</span>).<span style="color:#a6e22e">mymethod</span>(); <span style="color:#a6e22e">mi</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;SimpleStmt6 方法调用 (&amp;mi).mymethod(), mi&#34;</span>, <span style="color:#a6e22e">mi</span>)
	}
}
</code></pre></div><p><code>SimpleStmt1 空语句</code><!-- raw HTML omitted -->
<code>SimpleStmt2 通道发送 ch &lt;- 5</code><!-- raw HTML omitted -->
<code>SimpleStmt2 通道接收 _, ok = &lt;-ch true</code><!-- raw HTML omitted -->
<code>SimpleStmt3 加加减减 *ptr++ 6</code><!-- raw HTML omitted -->
<code>SimpleStmt3 加加减减 *ptr-- 5</code><!-- raw HTML omitted -->
<code>SimpleStmt4 赋值语句 i = 1</code><!-- raw HTML omitted -->
<code>SimpleStmt5 短变量声明 x :=  1</code><!-- raw HTML omitted -->
<code>SimpleStmt6 函数调用 myfunc(&amp;mi), mi 3</code><!-- raw HTML omitted -->
<code>SimpleStmt6 方法调用 (&amp;mi).mymethod(), mi 4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/c_2sGJNDtyr"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<h2 id="102-for">10.2 for循环执行</h2>
<p>for循环语句能够根据条件重复执行一个语句块，在Go语言中，for循环语句有3种形式：</p>
<p><strong>形式一： for直接加Condition</strong> <!-- raw HTML omitted --></p>
<blockquote>
<p>for Condition {<!-- raw HTML omitted -->
    // do something<!-- raw HTML omitted -->
}</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">0</span>

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p><code>0</code><!-- raw HTML omitted -->
<code>1</code><!-- raw HTML omitted -->
<code>2</code><!-- raw HTML omitted -->
<code>3</code><!-- raw HTML omitted -->
<code>4</code><!-- raw HTML omitted --></p>
<p>上例中<code>i &lt; 5</code>相当于Condition。</p>
<p><a href="https://play.golang.org/p/eaaUOkqtl37"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><strong>形式二： for后面跟3个分句<code>InitStmt;Condition;PostStmt</code>，分句之间用<code>;</code>隔开</strong> <!-- raw HTML omitted --></p>
<blockquote>
<p>for InitStmt;Condition;PostStmt { <!-- raw HTML omitted -->
    // InitStmt可以是简短变量声明的形式，这样的话InitStmt<!-- raw HTML omitted -->
    // 的有效范围仅在for循环体内，每次迭代时重复使用。<!-- raw HTML omitted -->
}</p>
</blockquote>
<p>InitStmt和PostStmt的格式就是SimpleStmt，只不过InitStmt在for循环开始时只执行一次，PostStmt是在每次for循环的语句块结束之后才执行一次。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}
</code></pre></div><p><code>0</code><!-- raw HTML omitted -->
<code>1</code><!-- raw HTML omitted -->
<code>2</code><!-- raw HTML omitted -->
<code>3</code><!-- raw HTML omitted -->
<code>4</code><!-- raw HTML omitted --></p>
<p>上例中<code>i := 0</code>相当于InitStmt， <code>i &lt; 5</code>相当于Condition, <code>i++</code>相当于PostStmt。</p>
<p><a href="https://play.golang.org/p/PM68Sh_yN7K"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<hr>
<p>**for后面的3个分句都可以省略，主要分为以下几种情况：**<!-- raw HTML omitted --></p>
<p>for分句省略情况一: 如果省去InitStmt或PostStmt，需要保留与其相邻的<code>;</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Remove InitStmt&#34;</span>)
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}
</code></pre></div><p><code>Remove InitStmt</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>1</code><!-- raw HTML omitted -->
<code>2</code><!-- raw HTML omitted -->
<code>3</code><!-- raw HTML omitted -->
<code>4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/Wxa6Z8Tia9U"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Remove PostStmt&#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p><code>Remove PostStmt</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>1</code><!-- raw HTML omitted -->
<code>2</code><!-- raw HTML omitted -->
<code>3</code><!-- raw HTML omitted -->
<code>4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/lJzwLN6Lsi2"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<hr>
<!-- raw HTML omitted -->
<p>for分句省略情况二: 如果同时省去InitStmt和PostStmt, 则Condition前后的2个<code>;</code>可以保留也可以不保留。<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Remove InitStmt and PostStmt, reserve smeicolons&#34;</span>)
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>;  {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p><code>Remove InitStmt and PostStmt, reserve smeicolons</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>1</code><!-- raw HTML omitted -->
<code>2</code><!-- raw HTML omitted -->
<code>3</code><!-- raw HTML omitted -->
<code>4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/eZB_ffc9kWc"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Remove InitStmt and PostStmt, remove smeicolons&#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p><code>Remove InitStmt and PostStmt, remove smeicolons</code><!-- raw HTML omitted -->
<code>0</code><!-- raw HTML omitted -->
<code>1</code><!-- raw HTML omitted -->
<code>2</code><!-- raw HTML omitted -->
<code>3</code><!-- raw HTML omitted -->
<code>4</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/krr8TCD5pkq"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<hr>
<!-- raw HTML omitted -->
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {
for i := 0; ; i++ {
fmt.Println(&ldquo;Remove Condition&rdquo;)
fmt.Println(i)
}
}</p>
<pre><code>
`Remove Condition`&lt;br&gt;
`0`&lt;br&gt;
`Remove Condition`&lt;br&gt;
`1`&lt;br&gt;
`Remove Condition`&lt;br&gt;
`2`&lt;br&gt;
`Remove Condition`&lt;br&gt;
`3`&lt;br&gt;
`...`&lt;br&gt;

[**🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣**](https://play.golang.org/p/V4Pa36kfqXs)&lt;br&gt;&lt;br&gt;

*** 
&lt;br&gt;
for分句省略情况四: 如果将InitStmt;Condition;PostStmt全部省去,则相当于一个Condition为true的for循环程序。&lt;br&gt;
以下2个程序是等价的, 它们均输出无尽的`Remove all for clauses`打印

```go
package main

import &quot;fmt&quot;

func main() {
	for {
		fmt.Println(&quot;Remove all for clauses&quot;)
	}
}
</code></pre><p><code>Remove all for clauses</code><!-- raw HTML omitted -->
<code>Remove all for clauses</code><!-- raw HTML omitted -->
<code>Remove all for clauses</code><!-- raw HTML omitted -->
<code>Remove all for clauses</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/ghQ5YPTJGOw"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a><!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">true</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Remove all for clauses&#34;</span>)
	}
}
</code></pre></div><p><code>Remove all for clauses</code><!-- raw HTML omitted -->
<code>Remove all for clauses</code><!-- raw HTML omitted -->
<code>Remove all for clauses</code><!-- raw HTML omitted -->
<code>Remove all for clauses</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/y3e4qJT5Be-"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<p><strong>形式三： for-range语句, range右边的Expression代表array, slice, string, map或者chan类型变量的一种</strong></p>
<blockquote>
<p>for IterationValueList := range Expression { <!-- raw HTML omitted -->
    // IterationValueList为短变量声明，每次迭代重复使用，<!-- raw HTML omitted -->
    // 有效范围仅在for循环体内。<!-- raw HTML omitted -->
}<!-- raw HTML omitted -->
或
<!-- raw HTML omitted -->
for IterationValueList = range Expression { <!-- raw HTML omitted -->
    // IterationValueList是在for循环外声明，每次迭代重复使用, <!-- raw HTML omitted -->
    // for循环结束后IterationValueList仍有效。<!-- raw HTML omitted -->
}</p>
</blockquote>
<p>for-range 的IterationValueList在Expression为array, slice, string或map时，IterationValueList均有2个值，如下表的
1st iteration value和2nd iteration value, 2nd iteration value是可以省略的。<!-- raw HTML omitted -->
Expression为chan时，IterationValueList只有1st iteration value这1个值，这个值不能省略，代表从ch中接收的元素值，具体情况见下表：</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Expression Type</th>
<th>Expression Variable</th>
<th>1st iteration value</th>
<th>2nd iteration value</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td>[&hellip;]T</td>
<td>a</td>
<td>int类型的索引值i</td>
<td>第i个数组元素a[i]</td>
</tr>
<tr>
<td>slice</td>
<td>[]T</td>
<td>s</td>
<td>int类型的索引值i</td>
<td>第i个切片元素s[i]</td>
</tr>
<tr>
<td>string</td>
<td>T</td>
<td>str</td>
<td>int类型的索引值i</td>
<td>第i个rune类型的UTF-8字符</td>
</tr>
<tr>
<td>map</td>
<td>map[K]V</td>
<td>m</td>
<td>K类型的键值k</td>
<td>m[k]</td>
</tr>
<tr>
<td>chan</td>
<td>chan T</td>
<td>ch</td>
<td>T类型的元素值</td>
<td>🈚️</td>
</tr>
</tbody>
</table>
<p>下面的例子说明了for-range Expression对应的5种情况，并且还为每种Expression额外遍历了Expression Type为指针类型的变量。
Expression Type为指针类型时，除了array类型的指针变量可以使用for-range进行遍历，其余4个类型均无法编译通过，因为这4个
类型是复合数据类型，range无法找到复合数据类型里的元素值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Expression: array&#34;</span>)
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: array pointer&#34;</span>)
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pa</span> <span style="color:#f92672">*</span>[len(<span style="color:#a6e22e">a</span>)]<span style="color:#66d9ef">byte</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pa</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;pa: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}
	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: slice&#34;</span>)
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#75715e">//fmt.Println(&#34;\nExpression: slice pointer&#34;)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//var ps *[]byte = &amp;s
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//for i, v := range ps {
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	fmt.Printf(&#34;ps: %d %c\n&#34;, i, v)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: string&#34;</span>)
	<span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;abcde&#34;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">str</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;str: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#75715e">//fmt.Println(&#34;\nExpression: string pointer&#34;)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//var pstr *string = &amp;str
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//for i, v := range pstr {
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	fmt.Printf(&#34;pstr: %d %c\n&#34;, i, v)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: map&#34;</span>)
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">byte</span>{<span style="color:#ae81ff">0</span>: <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">1</span>: <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#ae81ff">2</span>: <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#ae81ff">3</span>: <span style="color:#e6db74">&#39;d&#39;</span>, <span style="color:#ae81ff">4</span>: <span style="color:#e6db74">&#39;e&#39;</span>}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m: %d %c\n&#34;</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#75715e">//fmt.Println(&#34;\nExpression: string pointer&#34;)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//var pm *map[int]byte = &amp;m
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//for k, v := range pm {
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	fmt.Printf(&#34;pm: %d %c\n&#34;, k, v)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: chan&#34;</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#39;a&#39;</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#39;b&#39;</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#39;c&#39;</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#39;d&#39;</span>
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#39;e&#39;</span>
	close(<span style="color:#a6e22e">ch</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">ele</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;ch: %c\n&#34;</span>, <span style="color:#a6e22e">ele</span>)
	}

	<span style="color:#75715e">//fmt.Println(&#34;\nExpression: chan pointer&#34;)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch = make(chan byte, 5)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- &#39;a&#39;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- &#39;b&#39;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- &#39;c&#39;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- &#39;d&#39;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ch &lt;- &#39;e&#39;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//close(ch)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//var pch *chan byte = &amp;ch
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//for ele := range pch {
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	fmt.Printf(&#34;ch: %c\n&#34;, ele)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>Expression: array</code><!-- raw HTML omitted -->
<code>a: 0 a</code><!-- raw HTML omitted -->
<code>a: 1 b</code><!-- raw HTML omitted -->
<code>a: 2 c</code><!-- raw HTML omitted -->
<code>a: 3 d</code><!-- raw HTML omitted -->
<code>a: 4 e</code><!-- raw HTML omitted --></p>
<p><code>Expression: array pointer</code><!-- raw HTML omitted -->
<code>pa: 0 a</code><!-- raw HTML omitted -->
<code>pa: 1 b</code><!-- raw HTML omitted -->
<code>pa: 2 c</code><!-- raw HTML omitted -->
<code>pa: 3 d</code><!-- raw HTML omitted -->
<code>pa: 4 e</code><!-- raw HTML omitted --></p>
<p><code>Expression: slice</code><!-- raw HTML omitted -->
<code>s: 0 a</code><!-- raw HTML omitted -->
<code>s: 1 b</code><!-- raw HTML omitted -->
<code>s: 2 c</code><!-- raw HTML omitted -->
<code>s: 3 d</code><!-- raw HTML omitted -->
<code>s: 4 e</code><!-- raw HTML omitted --></p>
<p><code>Expression: string</code><!-- raw HTML omitted -->
<code>str: 0 a</code><!-- raw HTML omitted -->
<code>str: 1 b</code><!-- raw HTML omitted -->
<code>str: 2 c</code><!-- raw HTML omitted -->
<code>str: 3 d</code><!-- raw HTML omitted -->
<code>str: 4 e</code><!-- raw HTML omitted --></p>
<p><code>Expression: map</code><!-- raw HTML omitted -->
<code>m: 0 a</code><!-- raw HTML omitted -->
<code>m: 1 b</code><!-- raw HTML omitted -->
<code>m: 2 c</code><!-- raw HTML omitted -->
<code>m: 3 d</code><!-- raw HTML omitted -->
<code>m: 4 e</code><!-- raw HTML omitted --></p>
<p><code>Expression: chan</code><!-- raw HTML omitted -->
<code>ch: a</code><!-- raw HTML omitted -->
<code>ch: b</code><!-- raw HTML omitted -->
<code>ch: c</code><!-- raw HTML omitted -->
<code>ch: d</code><!-- raw HTML omitted -->
<code>ch: e</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/ZxIAielzP4y"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<p>如果5种range Expression的变量均为0值，则:<!-- raw HTML omitted --></p>
<ol>
<li>array和array ptr是可以被for-range迭代的。<!-- raw HTML omitted --></li>
<li>slice，string，map无法被for-range迭代。<!-- raw HTML omitted --></li>
<li>chan的迭代会一直阻塞，使程序出现死锁。<!-- raw HTML omitted --></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Expression: zero value array&#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pa</span> <span style="color:#f92672">*</span>[len(<span style="color:#a6e22e">a</span>)]<span style="color:#66d9ef">byte</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: zero value array pointer&#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pa</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;pa: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}
	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: nil slice?&#34;</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: empty string?&#34;</span>, <span style="color:#a6e22e">str</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">str</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;str: %d %c\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: nil map?&#34;</span>, <span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;m: %d %c\n&#34;</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
	}

	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\nExpression: nil chan?&#34;</span>, <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">ele</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;ch: %c\n&#34;</span>, <span style="color:#a6e22e">ele</span>)
	}

	<span style="color:#75715e">// or empty a channel directly
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// for range ch {}
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//------------------------------------------------------
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>Expression: zero value array</code><!-- raw HTML omitted -->
<code>a: 0 </code><!-- raw HTML omitted -->
<code>a: 1 </code><!-- raw HTML omitted -->
<code>a: 2 </code><!-- raw HTML omitted -->
<code>a: 3 </code><!-- raw HTML omitted -->
<code>a: 4 </code><!-- raw HTML omitted --></p>
<p><code>Expression: zero value array pointer</code><!-- raw HTML omitted -->
<code>pa: 0 </code><!-- raw HTML omitted -->
<code>pa: 1 </code><!-- raw HTML omitted -->
<code>pa: 2 </code><!-- raw HTML omitted -->
<code>pa: 3 </code><!-- raw HTML omitted -->
<code>pa: 4 </code><!-- raw HTML omitted --></p>
<p><code>Expression: nil slice? true</code><!-- raw HTML omitted --></p>
<p><code>Expression: empty string? true</code><!-- raw HTML omitted --></p>
<p><code>Expression: nil map? true</code><!-- raw HTML omitted --></p>
<p><code>Expression: nil chan? true</code><!-- raw HTML omitted -->
<code>fatal error: all goroutines are asleep - deadlock!</code><!-- raw HTML omitted --></p>
<p><code>goroutine 1 [chan receive (nil chan)]:</code><!-- raw HTML omitted -->
<code>main.main()</code><!-- raw HTML omitted -->
<code>	/tmp/sandbox257575067/prog.go:38 +0x8c0</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/PjoRzJxJfwy"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<hr>
<p><strong>for语句中有2个变量的示例</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34; i&#34;</span>, <span style="color:#e6db74">&#34;    j&#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> = <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">j</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%2d    %2d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
	}
}
</code></pre></div><p><code> i     j</code><!-- raw HTML omitted -->
<code> 0     0</code><!-- raw HTML omitted -->
<code> 1     2</code><!-- raw HTML omitted -->
<code> 2     4</code><!-- raw HTML omitted -->
<code> 3     6</code><!-- raw HTML omitted -->
<code> 4     8</code><!-- raw HTML omitted -->
<code> 5    10</code><!-- raw HTML omitted -->
<code> 6    12</code><!-- raw HTML omitted -->
<code> 7    14</code><!-- raw HTML omitted -->
<code> 8    16</code><!-- raw HTML omitted -->
<code> 9    18</code><!-- raw HTML omitted -->
<code>10    20</code><!-- raw HTML omitted --></p>
<p><a href="https://play.golang.org/p/5PE6Gj67HVl"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<h2 id="103-switch">10.3 switch多路执行</h2>
<p>switch-case语句有2种形式，第一种是值的比较，称作expression-switch（表达式switch）, 第二种是类型的比较, 称作type-switch(类型switch)。</p>
<p><strong>expression-switch</strong></p>
<p>跟在switch后面的表达式称作条件表达式。在expression-switch中，case表达式按照从左到右，从上至下的方向取值。
当第一个case表达式与条件表达式相等时，这个case分支的语句将会被执行，其他的case值语句将会被跳过。条件表达式和case表达式需要是可比较的关系。
switch里还有个default分支，当所有的case值都不等于switch的表达式值时，default分支的语句将会被执行。switch语句里只能有一个default分支，default
分支可以放在switch语句里的任何位置。</p>
<p>一个简单的expression-switch示例<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;1st case&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;2nd case&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;3rd case&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;default&#34;</span>)
	}
}
</code></pre></div><p><code>2nd case</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<p>fallthrough会把switch语句中case或default的控制传递给下一条语句。注意fallthrough不能用在switch语句的最后一个分支。<!-- raw HTML omitted --></p>
<p>一个简单的带fallthrough的expression-switch示例<!-- raw HTML omitted --></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;1st case&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;2nd case&#34;</span>)
		<span style="color:#a6e22e">fallthrougth</span>
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;3rd case&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;default&#34;</span>)
	}
}
</code></pre></div><p><code>2nd case</code><!-- raw HTML omitted -->
<code>3rd case</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<p>如果省去switch的条件表达式，同for循环省去所有分句一样，默认等于布尔值true。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">true</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;true&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">false</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;false&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;default&#34;</span>)
	}
}
</code></pre></div><p><code>true</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<p><strong>type-switch</strong><!-- raw HTML omitted -->
type-switch比较的是变量的类型， 在switch语句的条件表达式中求的是变量的类型，case表达式中列的是各种已知的类型。<!-- raw HTML omitted -->
加入要用type-switch比较一个变量i的类型，switch语句的条件表达式须写成i.(type), 用于表示求i的类型。type关键字在这里是固定格式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">unknown</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">unk</span> <span style="color:#a6e22e">unknown</span>

	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">interface</span>{}{<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">1.23</span>, <span style="color:#e6db74">&#34;123&#34;</span>, <span style="color:#a6e22e">unk</span>}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">i</span> {
		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span>.(<span style="color:#66d9ef">type</span>) {
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">nil</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;nil&#34;</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">bool</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;bool type, value:&#34;</span>, <span style="color:#a6e22e">v</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;int type, value:&#34;</span>, <span style="color:#a6e22e">v</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">float64</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;float64 type, value:&#34;</span>, <span style="color:#a6e22e">v</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;string type, value:&#34;</span>, <span style="color:#a6e22e">v</span>)
		<span style="color:#66d9ef">default</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unknown value type, value:&#34;</span>, <span style="color:#a6e22e">v</span>)
		}
	}
}
</code></pre></div><p><code>nil</code><!-- raw HTML omitted -->
<code>bool type, value: true</code><!-- raw HTML omitted -->
<code>int type, value: 123</code><!-- raw HTML omitted -->
<code>float64 type, value: 1.23</code><!-- raw HTML omitted -->
<code>string type, value: 123</code><!-- raw HTML omitted -->
<code>unknown value type, value: 0</code><!-- raw HTML omitted --></p>
<p><a href="-"><strong>🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  P L A Y A R O U N D 🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣 ♻️  🦑 🐣</strong></a></p>
<h2 id="104-select">10.4 select通道操作</h2>
<h1 id="11--1">11. 总结</h1>
<h2 id="heading-1">可以比较的类型</h2>
<p>以下5种类型在go语言中可以比较  //adm</p>
<p>比如boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.
但像切片、映射和函数是不可比较的类型，所以不能用作map的KeyType。</p>
<h2 id="heading-2">不可比较的类型</h2>
<p>以下5种类型在go语言中不可比较  //adm</p>
<ol>
<li>slice<!-- raw HTML omitted --></li>
<li>map<!-- raw HTML omitted --></li>
<li>函数<!-- raw HTML omitted --></li>
<li>含有不可比较类型元素的结构体<!-- raw HTML omitted --></li>
<li>元素类型为不可比较的数组<!-- raw HTML omitted --></li>
</ol>
<p><a href="https://play.golang.org/p/_zbYO7zEAw5"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<h2 id="untyped">无类型untyped</h2>
<h2 id="nil">零值为nil的类型</h2>
<p>go语言中以下几种类型的0值用nil表示  //adm</p>
<ol>
<li>pointer<!-- raw HTML omitted --></li>
<li>slice<!-- raw HTML omitted --></li>
<li>map<!-- raw HTML omitted --></li>
<li>function<!-- raw HTML omitted --></li>
<li>channel<!-- raw HTML omitted --></li>
<li>interface<!-- raw HTML omitted --></li>
</ol>
<p><a href="https://play.golang.org/p/_zbYO7zEAw5"><strong>🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 P L A Y A R O U N D 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣 🥨 🍒 🍣</strong></a></p>
<h2 id="printf">Printf打印参数</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">pm</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;C&#34;</span>: <span style="color:#ae81ff">1972</span>, <span style="color:#e6db74">&#34;Go&#34;</span>: <span style="color:#ae81ff">2009</span>}
	<span style="color:#a6e22e">ps</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span>[]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;break&#34;</span>, <span style="color:#e6db74">&#34;continue&#34;</span>}
	<span style="color:#a6e22e">pa</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span>[<span style="color:#f92672">...</span>]<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">pm</span>) <span style="color:#75715e">// *map[string]int
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">ps</span>) <span style="color:#75715e">// *[]string
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">pa</span>) <span style="color:#75715e">// *[4]bool
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="heading-3">可寻址和不可寻址</h2>
<p>addressable &amp; unaddressable
<a href="https://cloud.tencent.com/developer/article/1187626">参考链接</a></p>
<h2 id="heading-4">参考资料</h2>
<p><a href="https://go101.org">https://go101.org</a> <!-- raw HTML omitted -->
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a> <!-- raw HTML omitted -->
<a href="https://tour.golang.org/methods/16">https://tour.golang.org/methods/16</a> <!-- raw HTML omitted -->
<a href="https://golang.org/ref/spec#Method_sets">https://golang.org/ref/spec#Method_sets</a> <!-- raw HTML omitted --></p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Wenjun.Zhu </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://zhu-wenjun.github.io/2018/go/>https://zhu-wenjun.github.io/2018/go/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://zhu-wenjun.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://zhu-wenjun.github.io/2018/docker/" class="prev" rel="prev" title="Docker笔记"><i class="iconfont icon-left"></i>&nbsp;Docker笔记</a>
         
        
        <a href="https://zhu-wenjun.github.io/2019/smartnode/" class="next" rel="next" title="Smartcash 货币主节点">Smartcash 货币主节点&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">

    </div>
</article>
          
<div class="comments-container"></div>

          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://zhu-wenjun.github.io">Wenjun.Zhu</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  




     </div>
  </body>
</html>
